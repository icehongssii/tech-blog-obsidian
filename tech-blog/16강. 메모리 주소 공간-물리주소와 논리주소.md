안녕하세요 강민철입니다 자 이번

시간에는이 메모리를 학습하는데 있어서

너무너무 중요한 개념인 주소 공간에

대해서 말씀드려 보도록 하겠습니다

조금 더 정확하게는 이번 시간에는

<mark style="background: #FF5582A6;">물리 주소와

논리 주소에</mark> 대해서 학습해 볼

예정입니다 지금까지는

메모리 내 주소는 하나만 있다라고

상정을 하고 말씀을 드렸는데요 사실은

메모리 내에 주소 체계는 크게 두

가지가 있습니다 아시겠죠

논리 주소와

논리 주소가 있어요 다시 말해서

<mark style="background: #FF5582A6;">cpu와 실행 중인 프로그램의

입장에서 바라본 주소인

논리 주소가 있고요 논리적인 실제

주소는 아니지만 일단 논리적으로 이런

주소야라고 하는 식의 논리 주소가

있고요 그리고

메모리 내 실제 하드웨어 주소의

번지에 해당하는

물리주소라</mark>고 하는 개념이 있습니다

이번 시간에는이 논리 주소와

물리주소가 정확히 무엇인지 그리고 왜

이런 식으로 주소 체계를 논리 주소와

물리주소로 나누어서 관리하게 되었는지

그리고

논리 주소를 어떻게 물리주소로 변환할

수 있는지에 대해서 말씀드려 보도록

하겠습니다 아시겠죠

자 일단이 질문부터 시작해 보도록

합시다

<mark style="background: #FF5582A6;">cpu와

실행 중인 프로그램 다시 말해서 지금

메모리에 저장되어 있는 프로그램은

현재 메모리 몇 번지 다른

프로그램들이 무엇이 저장되어 있는지

다 알고 있을까</mark>요 예를 들어서 뭐

1번지부터 100번지까지

웹브라우저라고 하는 프로그램이

있다면이 웹브라우저 프로그램은 지금

5천 번지에 어떤 프로그램이 저장되어

있는지 12,000번지에

무엇이 저장되어 있는지 다 알 수가

있을까요

알 수가 없습니다 불가능에 가까워요

다시 말해서

cpu와 실행 중인 프로그램은 메모리

몇 번지에 무엇이 저장되어 있는지

하나부터 여기까지 다 알지는 못합니다

왜냐하면
<mark style="background: #FF5582A6;">
메모리에 저장된 값들은

시시때때로 변하기 때문이에요

매번 새롭게 시행되는 프로그램은

새롭게 보조기업 장치로부터 메모리로

적재가 되기도 하고요

실행이 끝난 프로그램은 메모리에서

이제 삭제가 되기도 하고요 그리고

같은 프로그램을 실행하더라도 뭐

어제는 1500번지에 적재되고 오늘은

뭐 12,000번지에 적재되고 내일은</mark>

다른 문제에 적재되고 이런 식으로

실행할 때마다 적재되는 주소는

달라지기 마련이기 때문입니다

그렇기 때문에 이런 상황에서

메모리 1번지부터

끝 번지까지 못 어떤 명령어들이

저장되어 있고

어떤 프로그램이 저장되어 있는지 일비

전부 다 알 수는 없겠죠

그렇죠 자 그렇기 때문에 이러한 점을

극복하기 위해서 주도 체계를

물리주소와

논리 주소로 나누었다라고 이해하시면

되겠습니다

몇 가지 이해가 되었죠

물리주소란 말 그대로 메모리 입장에서

바라본 주소입니다 그러니까

실제로 정보가 저장된 그 하드웨어

상의 주소 실제 주소 물리적인 주소를

물리주소라고 부릅니다 반대로 논리

주소는

cpu와

실행 중인 프로그램 입장에서 바라본

주소예요

그렇기 때문에 이제

실행 중인 프로그램 각각에게

0번지부터 시작하는 주소들을 다

부여를 하는데 그게 바로 논리

주소라고 보시면 됩니다 이걸 그림으로

표현해 보자면 이렇게 표현할 수가

있어요 지금 왼쪽에 나와 있는게

논리 주소입니다 그리고 오른쪽에 나와

있는게 물리주소예요

논리 주소는

각각의 실행중인 프로그램들 하나하나에

다 부여가 되어 있습니다 이런

식으로요<mark style="background: #FF5582A6;"> 그리고 모든 프로그램에 논리

주소마다 0번지가 있죠

그렇죠 여기도 0번지

0번지

0번지 즉 논리 주소는

0번지부터 시작되는 지금 실행 중인

프로그램들 각각에게 부여된 주소</mark>다라고

보시면 됩니다 반대로 논리 주소는

실제 하드웨어 상의 주소이기 때문에

0번지 하나밖에 없죠

그렇죠 예를 들어서 100번지가

있다면 100번지는 <mark style="background: #FF5582A6;">논리주소상에서

얼마든지 여러 개 있을 수 있다는

거예요

0번치도 마찬가지고요 여러분이 있을

수 있습니다 반면에

물리 주소는 겹치는 주소 번지가

없겠죠</mark>

그렇죠

여기까지 이해가 됐죠 그렇죠 그리고

논리 주소랑

프로그램을 실행하는

CPU 그리고 그 프로그램들 각각의

입장에서 바라본 주소다라고 이해하시면

되고요

물리 주소는

메모리 입장에서 바라본 실제 하드웨어

상의 주소다라고 보시면 되겠습니다

여기까지 이해 가서 쪼그죠이 그림

어렵지 않죠 자 근데 제가 앞서

말씀드렸다시피 논리 주소는

실행 중인 프로그램 즉 메모리에

적재되어 있는 프로그램 하나하나에게

각각의게 이제 0번지부터 시작한

주소를 부여한 주소 체계이기 때문에

얼마든지 같은 주소 번지가 중복돼서

있을 수가 있어요 예를 들어서

cpu는 이런 논리 주소를 실행

가져와서 실행했다고 하면 가정해

볼게요

인터넷 브라우저에 0번지에다가

a를 저장해 줘 게임

프로그램에

0번지에다가

0번지를 데이터를 삭제해 줘 이런

명령으로 실행했다고 한번 가정해봐요

근데

논리주소 상에서는 동일한 주소 번지가

얼마든지 있을 수가 있지만

물리주소에는 그렇지가 않죠

물리 주소에는 겹치는 주소 번지가

없잖아요

그렇죠 그렇기 때문에

결국에는이 cpu가

메모리와 상호작용을 하려면 결국에는

논리 주소를 물리주소로

변환하는 과정이 있어야 됩니다

이 말 이해하셨죠 그쵸 자 그렇다면

물리주소와 논리주소 사이에 주소

변환에 대해서 말씀드려 보도록

하겠습니다 자 이거는 그렇게 어렵지

않아요

cpu와 메모리 사이에 있는

<mark style="background: #FF5582A6;">mmu 메모리 관리 장치 메모리

매니지먼트 유닛의 약자예요

메모리 관리 장치

앞으로는 mmu라고 칭할게요이

mmu라고 하는 하드웨어에

의해서

논리 주소는

물리주소로 바뀌게 됩니다
</mark>
cpu가 실행하는 주소는

cpu가 이해하고

실행하는 주소는 다 논리 주소예요

근데이 논리 주소를 주소 버스를

통해서

실제로 메모리랑 메모리한테 쏘거나

메모리로부터 주소 버스를 통해서

받아들이는 주소 번지를 이제 cpu를

갖고 올 때는

항상이 mmu를 거치게 됩니다 그렇기

때문에 주소 버스를 통해서

메모리로부터 주소를 받아들일 때

물리주소는 논리 주소로 변환되고요

cpu가 주소 버스를 통해서

메모리한테 주소값을 쏴줄 때도

이 mmu를 통해서 논리 주소는 물리

주소로 변환이 됩니다

즉

mmu는 논리 주소와 물리주소 사이의

변환을 이루어주는 장치이다라고 보시면

되겠습니다 자 그렇다면이 mmu라고

하는 장치가 논리 주소를 물리주소로

어떻게 변환하는지 그 내부 과정에

대해서

간략하게

짚어 드리자면

<mark style="background: #FF5582A6;">mmu는

논리 주소 + 베이스레지스터(CPU 공부 할 때 나옴, 기준 주소 역할 하는 레지스터로 프로그램 시작 주소가 담긴다. 물리주소상의 프로그램 시작 주소 )
그리고 논리 주소는 어떻게 생각하시면 되냐면 실제로 저장되어 있는 그 프로그램으로부터 얼마나 떨어져 있느냐에 해당하는 정보가 바로 논리</mark>

주소다라고 생각하시면 편해요 자

이거는 그림으로 이해하시면 편해요

예를 들어서 지금

프로그램 a라고 하는

프로그램이 있어요이 프로그램 a는

15,000번지부터 뭐 예를 들어서

한 3만 번 집까지 실제 물리주소

상에서 저장되어 있다라고 가정을 해

볼게요 자 그러면

15,000번지부터 저장이 되고

있으니까

<mark style="background: #FF5582A6;">베이스 레지스터 즉 기준 주소에는

15,000에 넘깁니다

논리 주소는

각각의 프로그램의 0번지부터 부여하는

주소이기 때문에 지금이

논리 주소 100이라고 하는 건 어떤

말이냐면이 기준 주소로부터 100만큼

떨어진

곳이라고도 표현할 수가 있겠죠
</mark>
그렇죠이 말 혹시 이해하시나요 예를

들어서

논리주소상에서 프로그램 a의

100번지를 삭제해 주세요라는

명령어를 실행했다면 지금 논리 주소는

100번지지만 실제로는

15,000이라고

하는

기준 주소 즉 실제 프로그램 a가

저장되어 있는 첫 번째 주소 즉 기준

주소로부터 100번지

정도 떨어져 있는 값을 삭제해

주세요라는 말과 같습니다

베이스 레지스터와 논리 주소

즉 기준 주소와 그만큼 떨어진 거리를

더한 것이

물리주소다라고 이해하시면 됩니다

그렇기 때문에 실제로 삭제되는 물리

주소는 15,000번지가 되는 거죠

프로그램 a의

첫 번째 시작 주소 즉 물리적인 시작

주소는 15,000이 되겠죠 그렇기

때문에 베이스 레지스터

즉 기준 주소에는 15,000이

담깁니다 그리고 논리 주소는이 기준

주소로부터

얼만큼 떨어져 있느냐 어차피 논리

주소는 0번지부터 시작하니까이

기준 주소부터 얼만큼 떨어져 있느냐가

곧 논리 주소다라고 이해하시면 됩니다

그렇기 때문에

프로그램 a의 논리 주소 100번지를

삭제해 주세요라는 말은

곧

기준 주소로부터 100만큼

떨어진 곳을 삭제해주세요라고 하는

말과 같기 때문에

기준 주소로부터 100만큼 떨어진

15,100번지가 실제로 삭제가 되는

거죠

몇 가지 이해가셨죠 그쵸

다른 예시를 들어볼게요 예를 들어서

프로그램 c라고 하는 어떤

프로그램이 저장되어 있다라고 가정을

해 볼게요이 프로그램 c는

45,000번지부터 뭐 이를테면 한

5만 번지까지 저장되어 있다라고 한번

가정을 해 볼게요 자 그렇다면

45,000번지부터 저장되어 있다라고

제가 말씀드렸죠 그렇기 때문에 기준

주소는 뭐겠어요

기준 주소

즉 베이스 레지스터의 어떤 값이

담기겠어요

그렇죠 그리고 논리 주소 100번지를

삭제해 달라라고 하는이 명령어는

45,000이라고 하는이

기준점으로부터이 기준 주소로부터

100만큼 떨어져 있는 곳의 데이터를

삭제해 달라라고 하는 말과도 같겠죠

그렇기 때문에 실제로 삭제되는 물리

주소는

45,000원에서 100만큼 더한

45,100번지가 삭제가

논리주소 사이의 변화는

mmu라고 하는 하드웨어가 담당을

하는데이<mark style="background: #FF5582A6;"> mmu는

기본적으로 논리 주소와 물리주소의

변환을 어떻게 이루냐면

논리 주소와

베이스 레지스터 값을 더함으로써 이제

주소 변환을 이룬다라고 이해하시면

되겠습니다</mark>

물론 지금은 아직

운영체제를 배우지 않았기 때문에

페이징이라든지 이런 개념이 있긴

하거든요 근데 이거는

아주 기본적인 주소 변환 방법이라고

보시면 돼요 아시겠죠 이것 또한

실제로 뭐 공용책이라든지 대부분

대표적인 컴퓨터 구조 서적이라든지 다

소개하고 있는 대표적이고 기본적인

주소 변환 방법이거든요

그렇기 때문에 꼭 알아두시길 바랍니다

아시겠죠

<mark style="background: #FF5582A6;">자 정리하자면 베이스 레지스터는

프로그램의 가장 작은 물리 주소 즉

프로그램의 첫 번째

물리 주소를 저장하는 셈이고요

논리 주소는

프로그램 시작점 즉 베이스 레지스터에

담긴 값으로부터

떨어진 거리인 셈입니</mark>다

그렇죠 자 이렇게 정리하시면

되겠습니다 자 근데 여기서 문제가

있어요

<mark style="background: #FF5582A6;">다른 프로그램의 영역을 침범하는

명령어를

실행을 하면 안 됩니다이</mark> 말이 무슨

말인지 한번 예시를 통해서

말씀드릴게요 예를 들어서

현재 메모장이라고 하는 프로그램이

실행 중이라고 가정을 해 볼게요

그리고이 메모장이라고 하는 프로그램은

논리 주소상

0번지부터

99번지까지 있다라고 한번 가정을 해

볼게요 그리고이 메모장에

실제 주소 즉 물리 주소는

1000번지부터

199번지까지라고 한번 가정을

해볼게요 여기까지 이해가셨죠 그쵸 자

이런 상황에서 만약에 cpu가

메모장에 있는 명령어 중에서

1500번지

즉 논리 주소 1500번지에

숫자 100을 저장해라라고 하는

명령어가 있었고 이거를 실행했다라고

한번 가정을 해봅시다

이 명령어는이

명령어는

실행이 되어도 안전할까요

안되겠죠 저 왜냐면 메모장에 논리

주소는

0번지부터 99번지까지인데

1500번지를 저장해 버리면

베이스레지스터에는 지금

1000번지가 당기겠죠

그렇죠 그리고 메모장 논리 주소

1,500번지라고 하면은

결국에는 2500번지가

삭제가 되겠죠

그렇죠

그렇기 때문에 인터넷 브라우저에다가

숫자 100을 저장해 버리게 됩니다

논리 주소가 이제

99번지인데 거기에 초과되는

부분에다가 접근을 한 거니까요

다른 프로그램에 영역을 침범한

거니까요

또 다른 예시를 한번 들어볼게요 예를

들어서

인터넷 브라우저라고 하는 프로그램이

있다라고 가정을 해 볼게요 얘는

논리 주소상

0번지부터 99번지까지 있고

물리주소상 2천번지부터

2,99번지까지 저장되어 있었다라고

한번 가정을 해 볼게요 근데 만약에

인터넷 브라우저를 이루고 있는 명령어

중에서 이런 명령어가 있다고 해볼게요

논리 주소 1100번지의

데이터를 삭제해라라고 하는 명령어가

여기 있다고 한번 가정을 해볼게요이

명령어는

실행이 되어도 안전할까요

마찬가지로 안 되겠죠 왜냐면

인터넷 브라우저에 논리 주소 범위를

벗어난 명령어잖아요

얘를 실행하게 되면 애꾸준 게임

프로그램의 데이터를 삭제하게 되겠죠

그렇죠 왜냐면 2000번지에

1100을 더하면 3,100번지인데

3,100번지는 지금 게임 프로그램이

적재되어 있잖아요 그럼 에코준 게임

데이터를 지우게 되겠죠

그렇죠

이건 아까 전에 제가 말씀드렸던 그

예시에요 인터넷 브라우저에

1100번지 데이터를 삭제해라라고

한다면

베이스리지스터에는이 첫 번째 물리주소

즉 200번지

2000번지가 기준 주소로서 저장이

될 것이고

논리 주소 1100번지를 삭제해라

왜냐면 cpu가 받아들이고 해석하는

모든 주소는 다 논리주소예요 아시겠죠

1100번지를 삭제해라라고 하면은

논리주도 1100번지

2000이랑 더하면 3,100번지

게임 프로그램에 있는 데이터가 삭제가

되겠죠

그렇죠 자 이렇게 때문에
<mark style="background: #FF5582A6;">
메모리를 보호해야 되는 방법이

필요하게 되었습니다 즉

어떤 명령어가

다른 프로그램에 영역을 침범하지

않도록 메모리를 보호해야 돼요 자이

방법은 한 개 레지스터는 리미트

레지스터라고도 해요 리미트 레지스터

한 개 레지스터라고 하는
</mark>
어떤 특별한 추가적인 랜치스터를

통해서

메모리를 보호할 수가 있습니다

어떻게 프로그램에 영역을 침범하는 걸

이제 막아주냐면

논리 주소에 최대의 크기를

저장함으로써

프로그램에 영역을 침범하는 명령어의

실행을 막아줍니다 다시 말해서

베이스 레지스터가

실행 중인 프로그램의 가장 가장

작은

물리 주소를 저장한다면 한계 레지스터

즉 리미트 레지스터는

논리 주소의 최대 크기를 저장하고

있다라고 생각하시면 돼요 자 그렇기

때문에

프로그램의 물리 주소의 범위는 어떻게

되겠어요

베이스 레지스터 값보다는

크거나 같고

베이스 레지스터 값과 1개 레지스터

값보다

작겠죠

그쵸 이렇게 되니까요 이제

프로그램

프로그램에 물리 주소 범위는

베이스 레지스터 값보다 크고 이거 두

개 합친 값보다 작다 이렇게 특정

지을 수가 있겠죠

이 말 혹시 이해 가시나요 자 그렇기

때문에

어떤 명령어가 한 개 레지스터 값보다

큰 논리 주소에 접근하려고 하면은 그

명령어의 실행을 막아주면 됩니다 자

그러면 그 명령어가 이제 다른

메모리 주소를 침범할 일은 없겠죠

만약에

인터넷 브라우저

논리 주소 크기가 99번지까지

있잖아요 즉 1000개 주소 번지가

있잖아요 그쵸 자 여기서 한 개

레지스터는

천을 저장하고 있다라고 보시면 돼요

자 근데

실제로 접근하려고 하는 이제 명령어

주소가

천을 넘어가기 때문에 이런 거는
<mark style="background: #FF5582A6;">
실행을 막아주게 된다라고 보</mark>시면

됩니다

얘도 마찬가지예요

메모장은 주소가 1000개가 있습니다

논리 주소 상에서 자 그렇기 때문에

한 개 레지스터에는 천이 저장되어

있어요 만약에 cpu가 어떤 명령어로

실행할 때

천을 넘어가는 논리 주소에 접근하려고

들면은 그 명령어의 실행을 막아주면

됩니다 이런 것들도 맞겠죠 그쵸

그러면은

결과적으로는 여기 안에서이 범위

안에서 실행되는 명령어들만 실행될

수가 있겠죠

베이스 레지스터 이상

베이스 레지스터 더하기 한 개

레지스터

미만의 속한이 범위 내에서만 접근할

수 있도록 막을 수가 있겠죠

몇 가지 이해하셨죠 그쵸 또 예시를

통해서 알아볼게요

예를 들어서

베이스 레지스터의 배기 저장되어 있고

한 개 렌지스터에 150이 저장되어

있다라고 가정을 해 볼게요 자이 말은

무슨 말이냐면

물리주소의 시작점이 100번지다

그리고

프로그램의 크기 즉 논리 주소의 최대

크기가

150이다라고도 볼 수 있겠죠

즉이 프로그램은

100번지부터 250번지까지 이게

프로그램 크기라고 보시면 돼요

이만큼의 범위에 물리주수상에서

저장되어 있다라고 보시면 돼요

몇 가지 이해가셨죠 자 그렇기 때문에

얘보다 큰 주소에 접근하려고 들면

다시 말해서 이러한 명령어들을

실행하려고 돌면

막아주면 됩니다 어 너 지금 한 개

레지스터보다 큰 메모리 주소가 언제

접근하려고 하네 이런 거 실행하면 안

돼라고 막아주게 됩니다 그러면 이러한

불상사는 막을 수가 있겠죠

그렇죠

이런 경우도 마찬가지죠 만약에 베이스

레지스터의 1500이 저장되어

있다라고 가정을 해볼게요 그리고 한

개 레지스터의

천이 저장되어 있다라고 가정을 해

볼게요 자이 말은 무슨 말이냐면

물리주소의 시작점이 1500번지다이

프로그램은

물리주수상에서 1500번지부터

저장되어 있다 그리고

논리 주소의 최대 크기는

1000이다라고 하는 말과 같겠죠

다시 말해서

물리주도 상에서이 프로그램은

1500번지 이상 2500번지

미만으로 저장되어 있다라고 볼 수

있겠죠 그렇기 때문에 만약에이

프로그램을 이룬 명령어 중에서

천을 넘어가는 논리 주소에 접근하라고

들면 이런 식으로 이런 명령어의

실행은 막아주면 되겠죠

그렇죠 이런 식으로

프로그램에 실행에 독립적인 공간을

확보하고

다른 프로그램일 침범하는 일을

막을 수가 있습니다

몇 가지 이해하셨죠 그쵸 이게

처음 들었을 때는 아리까리할 수

있는데 예시를 통해서 학습하시다

보면은

그렇게 어렵지는 않을 거라고 믿습니다

아시겠죠 자 그러면 이번 강의는

여기까지 진행하도록 하겠습니다

감사합니다