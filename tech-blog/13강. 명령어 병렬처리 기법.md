
안녕하세요 강민철입니다 자 이번

시간에는

cpu에 대해서 학습할 때 너무너무

중요한 개념인 명령어 병렬 처리

기법에 대해서 학습해 보도록

하겠습니다

지난 시간에 멀티코어와 멀티스레드

cpu에 대해서 말씀을 드렸죠 그런

식으로

cpu를

조금 더 빠르게 처리할 수 있도록

설계를 하는 것도 중요하지만 어떻게

<mark style="background: #FF5582A6;">cpu가 시간 낭비 없이 시간을

알뜰살뜰이 쓰면서

메모리에 있는 명령어들을 빠르게

실행할 수 있는지도 중요하거든요 자

이번 시간에는 이와 관련해서이 명령어

병렬 처리 기법</mark>에 대해서 알아보도록

하겠습니다 아시겠죠 다시 말해서 그냥

cpu가 어떻게 시간을 알뜰살들이

쓰면서

명령어들을 빠르게 처리할 수 있는지를

학습하는 시간이라고 보시면 됩니다

아시겠죠

자 명령어 병렬처리 기법<mark style="background: #FF5582A6;"> 그 첫

번째는 명령어 파이프라인</mark>입니다이

명령어 파이프라인은 현대 cpu에

있어서 정말 없어서는 안드는 너무

중요한 개념이라고 볼 수 있는데요

하나의 명령어가 처리되는 과정을 한번

비슷한 시간 간격으로 한번 나눠

볼까요 제가 앞서 명령어가 cpu에서

어떻게 처리되는지 그 전 과정에

대해서는 한번 언급해 드린 적이

있었습니다 자 그 과정을 하나의

명령어가 처리되는 그 과정을 비슷한

시간 간격으로 나누면

다음과 같이 나눌 수가 있습니다

👉 명령어를 메모리로부터 가져오고 (인출)
👉갖고 온 명령어를 해석하고 해석한 
👉명령어를 실행하고
👉 필요하다면 그 결과값을 메모리에다가 다시 저장하고 이렇게 나누어 볼 수가

있습니다

참고로 말씀드리자면 이렇게 4개의

단계로 나누는 전공서도 있고요

전공수에 따라서 단순하게 그냥

인출해서

메모리로부터 갖고 와서

실행한다 이렇게 두 단계로 나누는

경우도 있고 이렇게 다섯 개의 단계로

나누는 경우도 있습니다 이게

절대적으로 정해진 아닌데 일단 이렇게

4개의 단계로 나누어 보겠습니다

아시겠죠 자 하나의 명령어가 처리되는

과정을 이렇게 4개의 단계로 비슷한

시간 간격을 나눴다면 여기서 중요한

건 뭐냐면 같은

단계가 겹치지만 않으면

<mark style="background: #FF5582A6;">cpu는 각각의 단계를

동시에 실행을 할 수가 있습니다 예를</mark>

들어서 지금

t1이라고 하는 시간 동안에는 하나의

cpu가 해석을 하는 동안에 다른

명령어를 동시에 갖고 올 수가

있습니다

t2에는 하나의 명령어를 실행하는

동안에는

다른 명령어를 해석하고 그 와중에 또

인출을 할 수가 있습니다 메모리로부터

갖고 올 수가 있습니다

즉 이런 식으로

명령어 1 2 3 4 이런 식으로

겹쳐서 실행을 할 수가 있어요

같은 단계가 겹치지만 않는다면요 자

이것이 바로

명령어 파이프라인이라고 보시면 됩니다

지금 보시면이 예를 들어서 T2 이동

안에는

명령어 1을 실행하고 명령어 인을

해석하고 명령어 3은 인출한다 이렇게

볼 수가 있겠죠 즉 세계의 명령어를

겹쳐서 실행하고 있다라고도 볼 수

있겠죠 그쵸이 순간에는 이런 식으로

<mark style="background: #FF5582A6;">명령어를

동시에 병렬로써

처리하는 방법을 명령어 파이프라인이

명령어 파이프라인이라고 부릅니다</mark> 이건

마치

컨베이어 벨트랑 비슷하죠 그렇죠 뭐

어떤 사람은 뭐 인출하고 해석하고

실행하고 저장하고 이거를 계속 쭉

멈추지 않고

컨베이어업처럼 반복하는 과정이라고도

빗대어서 생각해 볼 수가 있습니다 자

이렇게

겹치지만 않는다면

각 단계를 동시에 실행할 수 있다

명령어를 처리하는

각 단계를

동시에 실행할 수 있다이 개념이

명령어 파이프라인이라고 보시면 됩니다

아시겠죠

요컨대 동시에 여러 개의 명령어를

겹쳐서 실행하는 기법이

라고 보시면 되겠습니다 아시겠죠

명령어 파이프라인을 사용하지 않는다면

다시 말해서 하나의 명령어를 끝까지

다 처리하고 그 다음에 또 하나의

명령어를 끝까지 다 처리하고 그

다음에 또 하나의 명령어를 끝까지 다

처리하고 이런 식으로 이제 명령어

파이프라인을 사용하지 않는다면

당연하게도 지금 한눈에 봐도 시간이

정말 길어지는 걸 볼 수가 있죠

그렇죠 명령어 파이프라인을 사용했던

것보다

그렇죠

그렇기 때문에

현대 cpu에서는 이렇게 명령어를

겹쳐서 동시에 실행하는 기법인 명령어

파이프라이닝이 정말 중요한 기술로서

자리매김했다라고 보시면 되겠습니다

아시겠죠

<mark style="background: #FF5582A6;">자 근데 여기서 명령어 파이프라인을

학습하실 때 꼭 맞물려서 이제

알아두셔야 되는게 파이프라인

위험이라고 하는 요</mark>소가 있습니다

명령어 파이프라인이

항상 이런 식으로 이상적으로 이렇게

쭉 이렇게 겹쳐서 실행할 수 있는 건

아니에요 때로는

명령어 파이프라인이 이렇게 성능

향상에 실패하는 경우도 있습니다

동시에 명령어를 처리할 수 없는

경우도 있어요 자 그거를

파이프라인 위험 <mark style="background: #FF5582A6;">파이프라인 해저드라고

부릅니다 자 여기에는

크게 세 가지 종류가 있습니다</mark> 하나는

<mark style="background: #FF5582A6;">데이터 위험</mark> 또 하나는 <mark style="background: #FF5582A6;">제어 위험</mark> 또

하나는

<mark style="background: #FF5582A6;">구조적 위험이</mark>라고도 부릅니다

데이터 해저드 컨트롤 해저드

스트럭처를 해서든 이렇게도 불러요

어쨌든 파이프라인이 이런 식으로

명령어를 겹쳐서 실행하는 이런 과정이

제대로 동작하지 않는 경우 즉 병렬로

이제 명령어가 올바르게 실행되지 않는

상황을

파이프라인 위험이라고 하는데 거기에는

이런 세 가지 종류가 있다라고 기억해

두시면 되겠습니다 아시겠죠 자 일단

데이터 위험이 무엇인지에 대해서

알아보죠

<mark style="background: #FF5582A6;">데이터 위험은

명령어 간의

의존성 때문에 생겨나는 위험</mark>이라고

보시면 됩니다

즉 명령어간에

의존성이 있어서

명령어를

단순하게 병렬로 처리할 수 없는

상황을

데이터 위험이라고 부릅니다 모든

명령어를 동시에 처리할 수 없어요

이전 명령어를

끝까지 실행해야만 비로소 실행할 수

있는 경우가 있습니다 예를 들어서

아래에 이런 식으로 명령어 1과 2가

있었다고 한번 가정을 해볼까요

명령어 1은

레지스터 2에 있는 값과 레지스터

3에 있는 값을 더한 값을 더한

결과를

레지스터 1에다가 저장해라라고 하는

명령어고요

명령어 2는

그렇게 더한 레지스터 1의 값과

레지스터 5를 더한 값을 4했다가

저장해라라고 하는 명령어입니다 자이

경우에는

명령어 1을 해석하는 동안에

명령어 1을 인출할 수가 없습니다

왜냐하면

이 명령어 1을 실행해서

레지스터 1이 2 더하기 3으로

업데이트가 된 뒤에 그 다음에

명령어 1을 인출해야 되니까요

그렇죠이

r1이라고 하는이 값이

결정이 되어야만

명령어 일을 실행할 수가 있겠죠

요컨데 얘를 해석하고 있는 동안에

얘를 인출하면 안 되겠죠

그렇죠 아직 이게 실행되지도 않았고

r1이라고 하는 값이

결정되지도 않았으니까요

그렇죠 이런 상황에서는 명령어 1과

2를 마냥 겹쳐서 실행할 수가

없습니다 이렇게 명령어간에

의존성에 의해서 야기하는 위험을

데이터 위험이라고 부릅니다 아시겠죠

<mark style="background: #FF5582A6;">제어 위험은

프로그램 카운터에 갑작스러운 변화

때문에 약이 되는 문제라고 볼 수

있습니다

프로그램 카운터가

갑작스럽게

어떤 특정 메모리 주소로 바뀌는

경우가 있어요 다시 말해서 cpu가

실행하고자 하는

메모리의 주소 번지가

갑작스럽게 다른 특정 메모리 주소

번지로

실행의 흐름을 바꾸게 되는 명령어들이

있어요</mark>

점프 명령어라든지

콜 명령어라든지 아니면 인터럽트라든지

예를 들어서 점프 60이라고 하는

명령어를 생각해 볼까요이 명령어를

실행하면

60번지로

실행의 흐름이 바뀌게 됩니다 프로그램

카운터도 60번지로

업데이트가 될 거예요 자 근데

기본적으로 명령어들은 이런 식으로

다음 명령어 다음 명령어 다음 명령

이런 식으로 순차적으로 갖고 오거든요

예를 들어서 10번지 명령어를

인출하고 해석하는 동안에 11번지를

인출하고 11번지를 해석하는 동안에

12번지를 순차적으로 이런 식으로

인출하고 이런 식으로

기본적으로는 일반적으로 이렇게

순차적으로 명령어들을 겹쳐서 실행하게

되는데

프로그램 카운터가 갑작스럽게 이렇게

특정 메모리 주소로 변경이 되버리면

어 실행해 보니까

야 60번지로 분기 해야겠다 다음부터

60번지 실행에라고

실행이 되어버리면 그 다음에 겹쳐서

실행하고 있었던 11번지 명령어

12번지 명령어들은

헛수고가 되겠죠 이만큼이

그렇죠 이거를 c는 다음에는

60번지 명령어를 실행해야 되니까요

이만큼의 헛수고겠죠

그렇죠 자 이렇게

프로그램 카운터가 갑작스럽게 변화되는

상황에서

파이프라이닝이

성능 향상에 실패하는 문제를 제어

위험이라고 부릅니다

몇 가지 이해하셨죠 참고로

말씀드리자면이 책에서는 자세히

다루지는 않았지만 <mark style="background: #FF5582A6;">이러한 상황을

방지하기 위해서

프로그램 카운터가 어느 번지로

어디로

점프할 것인지를 미리 예측하는 기술도

있습니다 그거를

분기 예측이라고도 불러요

브랜치 프리딕션이라고도 합니다 이런

기술도 있다</mark>

정도로만 이해하시면 되겠습니다 어쨌든

제어위험은

프로그램 카운터가

갑작스럽게 다른 어떤 특정이 메모리

주소로

변경될 때

야기하는 문제다라고 이해하시면

되겠습니다

그렇게 되면 이게 실행이 돼 버리면

그동안에 해석하고

인출하고 있었던 그 다음번지

명령어들은 다 헛수고가 되니까요

몇 가지 이해하셨죠 그쵸

자 마지막으로 <mark style="background: #FF5582A6;">구조 위험은 서로 다른

명령어가 같은 CPU 부품 예를테면

alu나 레지스터를

쓰려고 할 때

발생하는 위험이다라고 보시면

되겠습니다</mark>

여기까지 이해하셨죠 정리하자면 명령어

파이프라인은

여러 개의 명령어를 겹쳐서

실행하는 방법이다라고 볼 수 있고요

명령어를 겹쳐서 실행하게 되면 이런

식으로 파이프라이닝을 사용하지 않았을

때에 비해서

당연하게도 더 빠르게

명령어들을 실행할 수가 있습니다 다만

이런 명령어 파이프라인이 언제나 성능

향상에 기여하는 것은 아닌데

언제 명령어 파이프라인이 제대로

작동하지 않느냐

파이프라인 위험이 발생했을 때 명령어

파이프라이닝이 제대로 동작하지 않는다

그리고 파이프라인 위험에는

데이터 위험 제어 위험

구조 위험이 세 가지가 있다라고

정리하시면 되겠습니다

몇 가지 이해가셨죠 그쵸 자 슈<mark style="background: #FF5582A6;">퍼

스칼라는 </mark>개념은 간단합니다

여러 개의 파이프라이닝을 두는 구조를

의미에요 예를 들어서 이런 식으로 한

번에 두 가지의 명령어를 인출하고 두

가지의 명령을 해석하고 실행하고

저장할 수 있다면 이만큼 더 겹칠

수가 있겠죠 이건 달리 말해서 이렇게

여러 개의

벨트를 주는 것에도 빗대서 생각해 볼

수가 있습니다 제가 앞선 영상에서

하드웨어 스레드에 대해서 말씀드렸죠

각각의 코어가

동시에 수행할 수 있는 명령어의

단위를 이제 하드웨어적인 스레드라고

말씀드렸는데 그게 여러 개 있는

스레드를 멀티스레드 프로세서라고

불렀습니다 예를 들어서

8코어 16스레드 cpu라고 한다면

한 번에 16개의 명령어를

갖고 와서 해석하고 실행할 수 있는

cpu다라고도 볼 수 있다라고

말씀드렸죠 그쵸 자 그런 경우에는

이런 슈퍼스 칼라 구조를 사용할 수가

있겠죠 한 번에 여러 개의 명령어를

인출하고 해석하고

실행하고 저장하고 그리고이 구조를

겹쳐서 실행을 할 수가 있겠죠

슈퍼 스칼라는

여러 개의 명령어 파이프라인을 두는

기법이다라고 보면 되겠습니다

어렵지 않죠 그쵸

이론적으로는이

<mark style="background: #FF5582A6;">슈퍼스칼라 기법을 사용하면은

파이프라인 개수의 비례해서 처리

속도가 증가합니다 근데 현실적으로

그렇진 않아요 왜냐하면

슈퍼스 칼라이 기법을 사용을 하면은

당연히 관리해야 되는 파이프라인도

여러 개로 이제 증가를 할 거고

그만큼 파이프라인 위험도 증가하게

됩니다</mark>

그렇기 때문에 반드시 파이프라인

개수의 비례해서

처리 속도가 증가하지는 않아요

왜냐하면 파이프라인 개수가 늘어나면

파이프라인 위험도가 증가할 수밖에

없겠죠

그렇죠 그렇기 때문에 이론적으로는

파이프라인 개수에 비례하여서 성능이

증가되지만

꼭 그렇지는 않다 그리고 이유는 이것

때문이다라고 이해하시면 되겠습니다

아시겠죠

자 마지막으로 소개해드릴 명령어

<mark style="background: #FF5582A6;">병렬처리 기법은 비순차적

명령어 처리라고 합니다 이거는 out

of all the execution

영어로

OOE</mark> 이렇게 또 줄여서 많이 말해요

참고로 말씀드리자면이 비순차적 명령어

처리는 많은 전공서에서 다루는 개념은

아닙니다 근데이 비순차적 명령어

처리는

현대 CPU 발전에 있어서 너무

중요한 기여를 한

기술이기 때문에 그냥 제가

여러 논문들을 찾아서 넣었다고 보시면

돼요 아시겠죠 중요한 개념입니다 자

비순차적 명령어 처리는 비유하자면

지금 여기 제가 쏟아졌다시피 마치

명령어들간에

합법적인 세칙이라고 보시면 돼요이

비순차적 명령어 처리 기법은

파이프라인 중단을 막기 위해서

명령어를

순차적으로 처리하지 않는 처리

기법이라고 보시면 됩니다 예를 들어서

이런 상황을 한번 생각해 볼까요

지금까지 제가 말씀드렸던 것은 모두

다 순차적으로만 명령어를 처리하는

방식이었어요 예 맞춰서

100번지에이 명령어가 저장되어 있고

101번지에이 명령어 102번지

103번지 104번지 105번지

이렇게 명령어가 쭉 저장되어 있다고

했을 때 이것들을 처리하는 방식은

그냥 위에서부터 아래로 쭉

순차적으로만

실행을 했습니다

몇 가지 이해하셨죠 근데 이런

명령어를 이렇게 생긴 명령어를

순차적으로만 처리를 하면은 이렇게

이상적으로

겹쳐서 실행을 할 수가 없어요 여기

이렇게 겹쳐서 실행을 할 수가

없습니다 왜냐하면 이걸 보면서

말씀드릴게요 왜냐하면 지금 1번

명령어는 1이라고 하는 값을 메모리

100번지에다가 저장해라라고 하는

명령어죠

2번 명령어는 2라고 하는 값을

101번지에다 저장해라라고 하는

명령어죠 근데 3번지는

메모리 100번지와 101번지의 값을

102번지에 넣어라라고 하는

명령어입니다 자 근데 이거를

실행하려면 일반적으로

일반적으로이 명령어를 실행을 하려면

메모리 100번지에 값이 결정이

되어야 되고요

메모리 101번지의 값이 결정이

되어야 되죠

그러면 어떻게 되겠어 이거랑 이거는

실행이 끝까지 돼야겠죠 3번이

명령어를 실행하려면요 그렇죠 자

그렇기 때문에

명령어를 순차적으로만 실행을 해야

했다면 이렇게 1 2 3 4 5 6이

명령어는 이렇게 파이프라인 이렇게

겹쳐서 이상적으로 실행을 할 수가

없습니다

이렇게 끝까지 기다려야 되기 때문에

파이프라이닝에서 어떤 성능 향상을

끝까지 끌어올릴 수는 없어요

몇 가지 이해하셨죠 근데 만약에

이거를 3번을

맨 뒤로 이렇게 순서를 바꿔 버린다면

어떻게 될까요

이게 3번은 일단 이거부터

말씀드릴게요 3번은 여기로 올 수

있을까요 3번을 지금

6번 다음에 실행을 해도 전체

결과에는 영향이 없을까요

영향이 없겠죠 100번지에 1번

저장해라 101번지에 2번 저장해라

150번지 1번 저장해라 이거를

여기에 넣나 여기에 넣나

프로그램 전체 결과에는

변함이 없잖아요

그렇죠

결과적으로 변함이 없죠 이게

여기에 들어있나이 세 번째 만에

실행이 되나 마지막에 실행이 되나

결과적으로는 똑같습니다 결과는

그렇죠 근데 이렇게

순서를 바꿔서 실행을 하면은

파이프라이닝이

조금 더

원활하게 동작할 수 있다라고 볼 수

있습니다 그렇죠 지금 이게 마지막에

실행이 된다면 여기서 인출을 하게

되고이 시점은

101번지와 100번지의 값이 결정이

되어 있는 상태니까요

그렇죠 이렇게 의존성이 없는 명령어의

순서를 바꾸는 것만으로도

파이프라이닝에 중단을

방지할 수가 있습니다 자 이게

비순차적 명령어 처리에 예시라고 보면

돼요

근데 그렇다고 해서 아무 명령어나

순서를 바꿀 수 있는 건 아닙니다

예를 들어서 이런 명령어가 있다고

했을 때

1번과 3번은

순서를 바꿀 수가 당연히 없죠

왜냐하면 1번은

메모리 100번지에 1을 저장해라라고

하는 명령어고 2번은 101번지에

2번을 저장해라라고 하는 명령어인데

3번은 이거 두 개이 여기에 있는이

결과값을 바탕으로 수행해야 되는

연산이니까요

그렇죠 메모리 100번지에 있는 값과

메모리 101번지에 있는 값을

102번지에 넣어라라고 하는 건데

이거를 처음부터 실행해 버리면 안

되잖아요

1과 2를 끝내야지만 실행할 수가

있잖아요

그렇기 때문에 1과 3의 순서는 바꿀

수가 없고요 마찬가지로 1과 4의

순서도 바꿀 수가 없습니다 왜죠 1과

2를 토대로 3번의 값이 결정되고

이렇게 결정된 3번의 값을 토대로

4번을 연산하니까요

그렇죠 103번지를 연산하려면

102번지의 값이

결정이 돼야 되는데 102번지의 값이

결정되려면 1번이 실행되어야 되잖아요

그렇죠 그렇기 때문에 이렇게

아무렇게나 명령어를 순서를 바꿀 수는

없어요 이렇게 의존성이 없는 명령어만

순서를 바꿔서

실행을 할 수가 있습니다 다시 말해서

순서를 바꿔도 전체 프로그램의 실행

결과 실행 흐름에는 영향이 없는

경우에만 바꿔서 이제 명령어를 처리할

수가 있는 거예요

자 비 순차적 명령어 처리를 지원하는

cpu의 경우에는 이러한 어떤 판단

이런 건 바꿔서 실행할 수 있겠구나

이런 판단들을 다 알아서 해줍니다

어쨌든 이렇게

의존성 없는 명령어들 간의 순서를

바꿔서 처리하는 방식을 비순차적

명령어 처리 방식이라고 보시면

되겠습니다

여기까지 이해하셨죠 여기서

4번과 5번의 순서를 바꿀 수 있는

거는 아시겠죠

몇 가지 이해가 되셨죠 그쵸 자

그러면 이번 강의는 여기까지 찍도록

하겠습니다

감사합니다