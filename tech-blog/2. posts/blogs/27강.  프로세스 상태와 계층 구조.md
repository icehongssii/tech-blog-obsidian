---
title: 27강.  프로세스 상태와 계층 구조
created: 2024-02-27 16:37
last-updated: 2024-03-08 00:50
tags:
  - CS
  - 책-혼공컴운
  - book
---

## 👯‍♂️ Intro & tl;dr

Brief introduction about the topic or what the post will cover.

--- 

## 👯‍♂️ 메인포인트1

안녕하세요 강민철입니다 자 이번

시간에는 프로세스 상태와

계층구조에 대해서

이야기 해보도록 하겠습니다 저번

시간에 프로세스에 대해서 간략하게

말씀을 드렸는데요 혹시 저번 시간

수업을 못 들으셨던 분들은 저번

시간에 있는 강의를 먼저 보시고 이번

강의를 수강해 주시길 바라겠습니다

아시겠죠 자 프로세스 상태에 대해서

먼저 말씀드려 보도록 하겠습니다

프로세스 상태

별거 없죠 이런 거 보신 적

있으신가요 좀 끔찍한

화면이죠 그쵸 자 이거는

현재 마이크로소프트 엑셀이라고 하는

프로세스가 응답 없음이라고 하는

상태임을 나타내는 페이지입니다

나타내는 화면입니다 자 이번에는

윈도우 작업 관리자의 세부 정보에서

상태를 한번 봅시다 여기요 자 여기

상태를 보시면

여러 프로세스가 다양한 상태를 갖고

있음을 알 수가 있습니다

몇 가지 이해가셨죠 그렇죠 자 이렇게

프로세스는 모두 저마다의 상태가

있습니다

운영체제는 이러한 프로세스의 상태를

pcb에 기록해서 관리를 합니다

그리고 모든 운영체제는 아니지만 모든

운영체제는 아니지만 많은 운영체제는

이렇게

동시에 실행되는 각기 다른 상태로서

이렇게 동시에 시행되는 수많은

프로세스들을

계층적으로 관리합니다 자 지금부터

이런 프로세스의 상태와 프로세스 계층

구조에 대해서 알아보도록 하겠습니다

자 프로세스 상태 정확하게 말씀드리면

이제 프로세스 스테이트 프로세스

상태는

운영체제마다 조금씩 차이가 있습니다

하지만 뭐 많은 운영체제 대부분의

운영체제에서 공통적으로 사용하고 있는

### 프로세스의 상태

프로세스의 상태는

다음과 같이 5가지의 상태가 있어요

하나는

생성 상태 또 하나는

준비 상태 또 하나는 실행 상태 또

하나는 대기 상태 또 하나는 종료

상태 이렇게 5가지의 상태가 대부분의

운영체제에서 사용하고 있는

프로세스 상태라고 보시면 됩니다 일단

프로세스 생성 상태는 뭐냐면 이건 말

그대로 생성된 상태를 의미합니다

프로세스를 생성한다라고 하는 말의

의미는

점심시간에 pcb에 대해서 공부하셨죠

프로세스가

원래이 프로그램이라고 하는 데이터는

원래는 보조기억 장치에 저장되어 있는

데이터 덩어리에 불과하지만 이거를

실행하게 되면 프로세스가 생성되고

운영체제는이 프로세스한테

pcb를 할당해줍니다 그리고이

프로세 우리가 실행이 끝나게 되면이

pcb를 폐기한다라고 말씀드렸죠

이렇듯이 이제 막 메모리의 적재돼서

실행되기 시작한 프로세스이 pcb를

할당받은 상태의 프로세스를

생성 상태라고 부릅니다

프로세스가 생성 상태를 거쳐서 이제

언제든지 cpu를 할당받아서 실행할

수 있는 상태가 되면

준비 상태가 됩니다 아시겠죠

자 다음은 준비 상태

레디 스테이트입니다

준비 상태는 방금 말씀드렸던 것처럼

당장이라도 cpu를 할당받아서 실행할

수 있지만 다만 자신의 차례가 아니기

때문에 그냥 기다리는 상태를

의미합니다 자신의 차례가 된다면

실행 상태로 전환이 됩니다

실행 상태로요

참고로

준비상태인 프로세스가 실행 상태로

상태가 바뀌는 것 이제 실행 상태로

접어드는 것을

디스패치라고도

이야기를 합니다 아시겠죠 자 실행

상태 이거를 러닝스테이트라고도

이야기를 하는데요

실행 상태는 말 그대로 cpu를 이제

할당받아서 실행 중인 상태를

의미합니다 할당된 시간을 모두 사용할

시에 저번 시간에 말씀드렸던이 타이머

인터럽트라고 하는 할당된 시간을 전부

사용했음을 나타내는 이제 하드웨어

인터럽트 특별한 인터럽트가 발생하면은

다시

준비 상태로 되돌아가게 됩니다

그렇기 때문에

입출력 작업이 끝날 때까지

cpu를 계속해서 그

프로세스가 점거하고 있을 수는 없어요

그렇기 때문에

프로세스가 실행되는 도중에

입출력장치를 입출력 작업을 만나게

되면

입출력 작업을 만나게 되면 그 입출력

작업이 끝날 때까지 그 프로세스는

기다려야 됩니다 어차피 입출력 작업이

끝날 때까지 그 프로세스는 다른 할

일이 없을 테니까요

그렇죠 이렇게

입출력 작업을 만나게 된 프로세스는

대기 상태로 접어들게 됩니다 자 다시

말해서 대기 상태는 실행 중인

프로세스가

입출력 작업을 만났을 때

입출력 작업이 끝날 때까지 기다리는

상태를 대기 상태 블록드 스테이트라고

부릅니다 대기 상태는 언제 끝나게

되냐면이 출력 작업이 끝나면이 대기

상태가 끝나게 됩니다

입출력 작업이 끝났다라고 하는 말은

입출력 완료 인터럽트를 받았다라고도

바꿔서 쓸 수가 있겠죠 그렇죠 자

이런 식으로 대기 상태가 끝나게 되면

준비 상태로 다시 되돌아가게 됩니다

어렵지 않죠 그렇죠 그리고

종료 상태 종류 상태는 말 그대로

프로세스가 종료된 상태를 의미합니다이

프로세스가 종료되게 되면

당연하게도이 프로세스가 차지하고 있던

메모리 영역을 정리를 해야 되고이

프로세스가 할당받은 pcb는 폐기를

해야겠죠 자 이러한 상태를

종류 상태라고도 부릅니다

터미네이티드 스테이트라고도 불러요 자

이러한 상태들을

간략하게

다이아그램으로 표현해보면 다음과 같이

표현할 수가 있습니다 이거를 프로세스

상태 다이어그램이라고 하는데이 그림만

봐도 제가 방금 전에 말씀드렸던 모든

프로세스의 상태를 파악할 수가

있습니다 예를 들어서

프로세스가 이제 막 실행이 돼서

pcb를 발급받은 상태 다시 말해서

생성 상태

뉴스테이트라고도 불러요이 생성 상태가

되고 이제 당장이라도 cpu를

할당받아서 실행할 수 있을 정도로

준비가 되면

준비 상태로 접어든다라고 말씀드렸죠이

준비 상태는 언제든지 CPU

할당받아서 쓸 수 있지만 아직 자신의

차례가 아닌 상태를 의미해요

그러다가 자신의 차례가 되면 이 준비

상태가 자신이 cpu를 할당받아서

사용할 수 있는 상태가 되면

디스패치에서 이렇게 디스패치가 돼서

실행 상태로 접어들게 된다라고

말씀드렸고요 이렇게 실행 상태로 쭉

실행을 하다가 자기의 어떤

cpu를 할당받은 시간을 전부 다

사용하게 되면 다시 말해서 타이머

인터럽트를 받게 되면은 다시 준비

상태로 접어들게 되고

실행 상태가 쭉 실행이 되다가

지속이 되다가

입출력 작업을 하게 되면은 대기

상태로 접어든다라고 말씀드렸죠

입출력장치의 속도는

cpu의 작업 속도보다 일반적으로

아주 느리기 때문에 대기 상태로

접어들어서

입출력 작업이 끝날 때까지

기다리게 됩니다 그 상태를 대기

상태라고 말씀드렸습니다 그리고

입출력이 완료되면 다시 준비 상태로

접어든다라고 말씀드렸죠 그리고 실행

상태가 쭉 되다가 만약에 실행이

끝나면 이거를

종료 상태로 바꿔주면 되겠죠

pcb를 폐기하고 프로세스가 차지하고

있던 메모리 영역을 정리하는 상태를

종료 상태라고 있습니다 자 이것들이

프로세스의 상태라고 보시면

됩니다 아시겠죠 자 다음은 프로세스

계층구조인데요 대부분의

운영체제에서 이제 프로세스를

계층적으로 관리를 합니다

프로세스를

계층적으로 관리를 해요 근데 한 가지

예외는 있어요

엄밀하게 따지자면

윈도우 운영체제는 프로세스를

계층적으로 관리하지 않습니다 하지만

그럼에도 불구하고이 프로세스 계층

구조는 여러분들이 개발자 혹은 개발자

지망생으로서 반드시 알아야 되는

내용입니다 왜냐하면 개발자

분들이 많이 사용하는 운영체제는

윈도우라기보다는 뭐 리눅스나

macos나

넓게 보면 유닉스까지 이런 식으로

프로세스를 계층적으로 관리하는

운영체제를 많이 사용하게 되거든요

그렇기 때문에

프로세스가 계층적으로 관리되는

구조라는 무엇인지 프로세스 계층

구조란 무엇인지 꼭 알아둬야 된다라고

보시면 되겠습니다 아시겠죠

자 프로세스 계층구조에 대해서 이해를

하시려면 부모 프로세스와 자식

프로세스의 개념에 대해서 이해를

하셔야 됩니다 일단 프로세스는 실행이

되는 도중에

시스템 호출 이제 다른 프로세스를

생성해주는 시스템 호출을 통해서

다른 프로세스를 생성할 수가

있습니다이

시스템 호출이 무엇인지는 바로 뒤에

설명을 드릴게요 어쨌든 프로세스는

실행이 되는 도중에 또 다른

프로세스를 생성할 수가 있는데 이때

새로운 프로세스를 생성한 프로세스를

부모 프로세스 페넌트 프로세스라고도

부르고요 부호 프로세스에 의해서 이제

막 새로 생성된 프로세스를 자식

프로세스 차일드 프로세스라고도

부릅니다

어렵지 않죠 그쵸 부모 자식 관계랑

똑같죠 자 부모 프로세스랑

40프로세스는

별개의 프로세스이기 때문에

각기 다른 PID 값을 가집니다 예를

들어서

똑같은 프로그램을 두 번 실행해서

별개의 프로세스가 만들어졌다면 그 두

개의 프로세스는

다른 프로세스예요

PID 값이 다릅니다 아시겠죠 똑같은

프로그램을 두 번 실행했을지라도

아시겠죠 그리고 일부 운영체제에서는

자식 프로세스의 pcb에다가 부모

프로세스의 pid값 이거를

parent PID

줄여서 ppid라고 하기도 하는데요이

부모 프로세스의 pid를 명시하기도

합니다 몇

가지 이해가 되죠 그쵸 그리고 자식

프로세스 부모 프로세스로부터 생성된

자식 프로세스 또한 또 다른 자식

프로세스를 나눌 수가 있습니다 그리고

그렇게 생성된 자식 프로세스는 또

다른 자식 프로세스를 나올 수 있고

또 다른 자식 프로세스를 나올 수

있고 뭐 이런 식으로 자식 프로세스가

또 자식 프로세스를 낮고 자식

프로세스가 자식 프로세스를 낳고 이런

식으로

계층적인 구조를 형성하게 됩니다

몇 가지 이해가셨죠 이걸 그림으로

표현해 보자면 요렇게 표현할 수가

있겠죠 예를 들어서 컴퓨터가 딱

부팅되는 시점에 실행되는 최초의

프로세스가 있습니다 그리고이 최초의

프로세스는 요런 식으로 자식

프로세스들을

생성할 수가 있겠죠 자 그리고 이런

자식 프로세스들은

요러한 자식 프로세스들을

생성할 수가 있겠죠

그렇죠 자 여기까지 실행이 됐다면

현재 지금 시스템에서 실행되고 있는

프로세스는 몇 개예요

하나 둘

셋 넷 다섯 일곱 여덟 아홉 열 개의

프로세스가 현재 시스템에서

동시에 실행 중인 상태를

요렇게 간단하게 그림으로 그려 볼

수가 있는 거예요

몇 가지 이해가셨죠 그쵸 자 방금

전에 말씀드렸던이 프로세스 계층

구조를 예시를 통해서 알아보도록

하겠습니다

근데 미리 말씀드리자면 여기 이제

데몬 프로세스도 있죠

데몬 프로세스가 무엇인지는 저번

강의에서 말씀을 드렸죠

데몬이나 서비스 또한이 최초 프로세스

컴퓨터가 부팅될 때 바로 실행되는

최초의 프로세스의 자식 프로세스라고도

볼 수 있습니다

참고서 한번 말씀드리는 거예요

자 만약에 이제 여러분들이 컴퓨터를

딱 부팅 했을 때

생성된 최초의 프로세스가 이렇게

있다고 한번 가정을 해 볼게요 최초의

프로세스는

로그인을 담당하는 프로세스를 자식

프로세스로 생성한 셈이고요이 그림에

따르면 그리고

로그인 프로세스는 이제 사용자로부터

입력을 받을 수 있는 사용자

인터페이스 프로세스 배씨라고 하는

사용자 인터페이스 프로세스를 자식

프로세스로도 생성을 한 것이고요이

그림에 따르면 그리고 사용자

인터페이스 프로세스는 빔이라고 하는

자식 프로세스를

생성한 셈입니다이 그림에 따르면요

이런 식으로 최초의 프로세스가 로그인

프로세스를 만들고 로그인 프로세스는

대시를 배시는 비물 요런 식으로

순차적으로

자식 프로세스를 생성함으로써

여러 개의 프로세스가 동시에 실행되는

구조로써 컴퓨터가 실행된다라고 하는

점을 알 수가 있죠

그러면 최초의 프로세스는 그럼

뭐예요라고 궁금해 하실 분들이 계실

수도 있는데요 이거는 간단한

명령으로서 확인할 수가 있습니다 지금

제가 말씀드렸던 이런 프로세스

계층구조를

시각적으로 보여줄 수 있는 명령어가

있거든요 이거를 PS3

트리 형태로이 프로세스 현재 실행되고

있는 프로세스들을 보여라라고 하는

명령어인데요이 PS3

명령어를 이용하면 최초의 프로세스가

무엇인지를 알 수가 있습니다 가령

리눅스 운영체제에서는요 가장 여기 최

좌측에

시스템 d라고 하는 프로세스가

있거든요 자 이것이 컴퓨터가 부팅될

때 최초로 실행되는 프로세스다라고

보시면 돼요 아까 제가 말씀드렸던

이러한 데몬 프로세스들도 여기에 최초

프로세스의 자식으로서 이제

표현이 되어 있다는 걸 알 수가 있죠

참고로 말씀드리자면 옛날 운영체제

같은 경우에는 이닛이라고 하는 최초의

프로세스도 있습니다 근데 최근에는

시스템 d라고 하는 프로세스가 최초의

프로세스로서

잘 되고 있어요

메고 S 같은 경우에는 런치 D

런치 D 여기 밑에 보이시죠 런치

d라고 하는 프로세스가 최초의

프로세스 역할을 하고 있다라고 보시면

되겠습니다 아시겠죠 자이 최초의

프로세스가 자식 프로세스들을 생성을

하고 이거는 이제 그림 크기상

잘렸는데 지금 이러한 프로세스들도

자식 프로세스들을 막 생성하고 이런

식으로 막 가지치기처럼 이렇게 막

표현이 되거든요 실제로 명령어를

입력을 해보면 자 이런 식으로

프로세스들은 많은 운영체제에서

계층적으로 관리된다라고 보시면

되겠습니다 아시겠죠

자 여기까지가 원래 처음에이 강의를이

강의 그리고이 책을 집필할 때 원래

여기까지만 설명을 드리려고 했었는데

제가 좀 많이 고민을 하다가 이거는

제가 넣은 내용이에요 마지막에 막판에

고민하다가 이건 넣은 내용인데

프로세스 생성기법이라는 내용입니다

이거는 이것도 참고로 말씀드리자면

여기부터의 내용도

엄밀하게 말씀드리자면 윈도우 운영체제

하고는 관련이 없습니다 하지만

앞서 말씀드렸던 것처럼 개발자 혹은

개발자 지망생 분들이

정말 많이 접하게 될 운영체제에서는

지금부터 제가 설명해드릴 이러한

구조로써 프로세스가 생성되고

병행 시행된다라고 보시면 돼요 좀

중요한 내용이라고 생각을 해서

막판에 넣었다라고 보시면 되겠습니다

아시겠죠 자이 프로세스 생성기법은

이러한 질문으로부터 시작을 하는

내용이에요 부모 프로세스는 자식

프로세스를 어떻게 만들어내고 자식

프로세스는 어떻게 자신만의 코드를

실행할까 이런 질문부터 시작을 하는

거거든요

예를 들어서

로그인 프로세스가 110 프로세스를

자식 프로세스로써 생성을 했다라고

한번 가정을 해봅시다 자 그러면

로그인 프로세스라고 하는 부모

프로세스는 배씨 프로세스라고 하는

자식 프로세스를 어떻게

생성을 할까요 그리고 배씨

프로세스는이 프로세스를 차지하는

메모리상의 위치가 있지 않겠어요

그렇죠

로그인도 로그인 나름대로

메모리 안에 어떤 공간을 차지하고

있을 거고 110 프로세스 또한

메모리 안에 자기만의 영역을 차지하고

있겠죠 그리고

로그인 프로세스와 배시 프로세스는

서로 하는 일이 다르기 때문에

메모리 안에 저장되어 있는 내용들이

다를 겁니다

그렇죠 자 그렇다면이 로그인

프로세스로부터 생성된 자식 프로세스인

배씨라고 하는 프로세스는 어떻게

자신만의

코드를 메모리 안에 적재해서 실행할

수가 있었을까라고 하는 질문에서부터

시작되는게이 프로세스

생성기법이라고 보시면 됩니다 아시겠죠

자

결론부터 말씀드리자면 많은

운영체제에서는

윈도우하고는 큰 관련이 없습니다 많은

운영체제에서는

복제와

옷 갈아입기 이건 제가 나름대로

들었던 비유인데요

복제와

옷 갈아입기라고 하는이 두 가지의

과정을 거쳐서

프로세스가

생성된다 부모 프로세스로부터 자식

프로세스가 생성되고 자식 프로세스는

자신만의 코드를 실행할 수 있다라고

보시면 됩니다 자 이게

어떤 것을 의미하는지 지금부터

말씀드리도록 할게요

첫 번째 부모 프로세스는

포크라고 하는 시스템 호출을 통해서

자신의

복사본을 자식 프로세스로서 생성을

하고요 그리고 두 번째 자식

프로세스는 xecution이라고 하는

시스템 호출을 통해서 자신의 메모리

공간을 다른 프로그램으로 교체를

합니다 자이 두 개의 방법을 통해서

부모 프로세스는 작식 프로세스를

생성해내고 자식 프로세스는 자기

자신만의

프로그램을 실행할 수가 있게 되는

거예요이 첫 번째를

복제에 빗댄 거고요이 두 번째를

옷 갈아입기

에피 뗀 겁니다 자 조금 더 자세하게

말씀을 드릴게요 자 포크라고 하는

시스템 호출이 있습니다

포크라고 하는 시스템 호출은 자신의

복사본을 자식 프로세스로써

생성하세요라고 하는 시스템

호출입니다이 포크라고 하는 시스템의

주는 나의

복사본을 자식 프로세스로써

생성해라라고 하는

시스템 호출이기 때문에이 포크라고

하는 시스템 호출을

호출하면 그 호출한 프로세스 다시

말해서 부모 프로세스의 자원들 예를

들어서 메모리의 내용이라든지 열린

파일들의 목록 그런 어떤 부모

프로세스가 기존에 갖고 있었던

자원들이 자식 프로세스한테 상속이

됩니다 다시 말해서 그냥 포크라고

하는 시스템 호출을 딱 호출을

하면은이 호출한 프로세스이 부모

프로세스와

동일한 복사본이 자식 프로세스로서

생성된다라고 보시면 돼요

참고로 말씀드리자면

완전한 복사본이 만들어지기는 하지만

엄연히 별개의 프로세스이기 때문에

pid라든지 저장되어 있는 메모리의

위치는 다릅니다 아시겠죠 어쨌든

포크라고 하는 시스템 호출은 자신의

복사본을 자식 프로세스로서

생성해라라고 하는

시스템 호출입니다

여기까지 이해가셨죠 그쵸 자이 포크

시스템 호출이 끝났다면 자식

프로세스는 부모 프로세스와

완전히 동일한 내용들을 갖고 있겠죠

그렇죠 뭐 이런 영역들까지 부모

프로세스와 동일한 프로세스 동일한

프로그램으로써 자식 프로세스가

만들어지게 될 겁니다

자이 상태에서 그냥 부모 프로세스와

자식 프로세스를 쭉 실행을 시키면

어떻게 되겠어요

그냥

똑같은 일을 하는 두 개의 프로세스를

동시에 실행해라 이렇게 되겠죠

그렇죠 자 근데 여기서 자식

프로세스가

exec라고 하는 시스템 호출을 또

할 수가 있습니다

어떤 시스템 호출이냐면 내가 지금

갖고 있는 내 메모리 공간을

새로운 프로그램으로

덮어 써라라고 하는 시스템 호출입니다

다시 자신의 메모리 공간을

새로운 프로그램으로

덮어쓰는 시스템 호출입니다

새로운 프로그램 내용으로 전환해서

실행하는 시스템 호출 인셈이죠 자이

시스템 코를 호출하게 되면은

코드 영역 데이터 영역은

새롭게 실행할 프로그램의 내용으로

바뀌게 되고요 나머지 영역은 초기화가

됩니다 이거를 그림으로 표현해보자면

이렇게 변할 수가 있어요 자 부모

프로세스가 자신의 복사본을 자식

프로세스로써

고대로

포크 시스템 호출을 통해서 생성을

했습니다 자 여기까지만 보면은 부모

프로세스와 자식 프로세스는 완전히

동일한 프로세스를

동일 프로그램을 갖고 있다고도 볼 수

있겠죠

그렇죠 말 그대로 복제가 된 거죠

그리고 여기서 40%가

exec라고 하는

시스템 호출을 호출하게 된다면 여기에

있는이 스택 영역 심영역

데이터 영역 코드 영역에 해당하는

이러한 프로그램의 내용들이 내가

지금부터 실행할 새로운 프로그램으로

바뀌게 됩니다 자 그렇다면

여기서부터는 부모 프로세스가 갖고

있는 프로그램의 내용과 자식

프로세스가 갖고 있는 프로그램의

내용이

달라지게 되겠죠

서로 다른 프로그램을

병행해서 실행하는 꼴이 되겠죠

몇 가지 이해가셨죠 그쵸 예를 들어서

한번 설명을 드릴게요 만약에 사용자가

배씨라고 하는 쉘에서

쉘 프로세스에서

ls라고 하는 명령어를 한번 쳤다고

가정을 해 볼게요 자 그러면 배씨라고

하는 쉘 프로세스는

포크 시스템 호출을 통해서 배씨라고

하는 부모 프로세스는

포크라고 하는 시스템 호출을 통해서

자신과 똑같은 복제본 프로세스를 자식

프로세스로써 생성을 합니다 자 그리고

그렇게 생성된 부모 프로세스의

복제본인 자식 프로세스는

엑색 시스템 호출을 통해서

ls라고 하는 명령어를 실행하기 위한

프로세스로서 전환이 돼서 실행이

됩니다이 ls를 실행하기 위한

스택 영역 힘 영역 데이터 영역 코드

영역으로 바뀌어서

옷을 갈아입은 것과 비슷해요 그쵸

이렇게

ls라고 하는 명령어를 실행하기 위한

프로그램으로써

메모리 공간을 바꿔서 실행을 하게

됩니다 자 그러면 배시 프로세스는

그대로 실행이 되고 그대로 ls라고

좋아하는 명령어 ls라고 하는

프로그램이 실행이 되는 거예요

몇 가지 이해가셨죠 그쵸 자 정리를

해보자면 부모 프로세스가 자식

프로세스를 실행하고 프로세스의

계층구조를 이루는 과정은

포크 시스템 호출과 xxm 호출이

반복되는 과정이라고도 볼 수 있습니다

다시 말해서 부모 프로세스로부터 자식

프로세스가 복제되고 부모의

복제본으로서 생성된 자식 프로세스는

자신만의 프로그램을 실행하기 위한

메모리 공간을

엑색 시스템 호출을 통해서 채워

나가고 이런 식으로 이런 과정이

반복되는 과정으로서

시스템의 계층 구조가 만들어진다라고도

볼 수가 있어요 뭐 예를 들어서

프로세스가 있으면이 프로세스가

포크라고 하는 시스템 호출을 하게

되면 자신과 똑같이 생긴 프로세스가

복제 번호로써 만들어지고 그리고

40%가 x 시스템 호출을 하게 되면

옷을 갈아입는 것과 똑같게 되죠 부모

프로세스는 그대로 있고요 자 그러면은

이렇게 생긴

프로세스가 그대로 실행이 되고 또

이렇게 생긴 프로세스가 고대로

실행되고 자 이런 식으로

서로 다른 프로그램이

계층 구조를 이루면서

동행 실행되는 구조를 이룬다라고 볼

수가 있습니다

몇 가지 이해하셨죠 그쵸

물론 자식 프로세스가 부모

프로세스로부터

포크된 이후에 다시 말해서 만들어낸

뒤에 자식 프로세스가 이런 식으로

xx 시스템 호출을 하지 않는 경우도

있습니다 자 이럴 경우에는 그냥

똑같은 프로세스 똑같은 동일한 일을

수행하는 프로세스가 병행 실행되는

구조라고도 볼 수 있겠죠 몇 가지

이해하셨죠 그쵸 자 이게

프로세스의 생성기법 이거를

포크 엑셀

구조라고도 합니다 여기 나와 있죠

커먼리 유스 테크닉인 유닉스

어쩌고저쩌고 이렇게 써 있죠 그쵸

새로운 프로세스를 만들어내고

새로운 프로그램을 만들어내는 대표적인

과정입니다라고 나와 있죠 자 이거를

제가

복제와 옷 갈아입기라고 빗대서 설명을

드린 거예요

아시겠죠 이거 알아두시면 정말 큰

도움이 될 겁니다 아시겠죠

자 이번 강의는 여기까지

진행하도록 하겠습니다 여기까지

들어주신 여러분들 정말 정말

고생 많으셨습니다

감사합니다
## 👯‍♂️ Conclustion

Summarize the main points and conclude your post.

--- 

## 👯‍♂️ Ref & LINKS TO THIS PAGE

-  [책/유튜브 인강-혼자 공부하는 컴퓨터구조+운영체제, 강민철, 한빛미디어](https://www.youtube.com/watch?v=kFWP6sFKyp0&list=PLYH7OjNUOWLUz15j4Q9M6INxK5J3-59GC)
