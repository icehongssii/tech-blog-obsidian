

```ad-note
title: 키워드
- 명령어 사이클
- 인터럽트 ✨✨✨ (중요한 개념 )
```



## TL;Dr

- cpu는 메모리로부터 명령어, 데이터들을 갖고와 실행하고 필요시 값 저장한다.
- 이때 cpu가 메모리에 저장되어 있는 프로그램 실행하는 과정에  일정한 패턴, 일정한 주기가 있다! 👉 즉 cpu는 메모리 안에 있는 프로그램 어떤 정해진 흐름대로 처리하는데 그 정해진 흐름 주기를 명령어 사이클이라고 한다
- 간혹 그 정해진 흐름, 명렁어 사이클 방해한느 신호가 cpu에게 올 수 있는데 이 흐름을 끊는 신호를 인터럽트라고 한다


## 명령어 사이클

 - 즉 cpu는 메모리 안에 있는 프로그램 어떤 정해진 흐름대로 처리하는데 그 정해진 흐름 주기를 명령어 사이클이라고 한다
	 - 예) 프로그램을 실행한다면? 🤔💭
		 1. 인출사이클; 메모리에 있는 값을 cpu 레지스터 OR cpu 내부로 갖고온다. 이 작업을 인출이라고 한다, 이렇게 인출하는 주기를 인출사이클이라함
		 2. 실행사이클; 내부로 가져온 프로그램을 실행한다
		👉 일반적으로 cpu는 인출 사이클과 실행 사이클 반복, 이게 명령어 사이클의 일부이다 
- 인출을 하더라도 바로 실행이 불가능한 경우도 있습니다 추가적으로 메모리에 접근해야 되는 경우가 있을 수가 있다 -> 간접 주소지정 방식이라

		


## 인터럽트 




cpu는

프로그램 속의 명령어들을 일정한

주기를 반복하면서 실행을 합니다

그리고이 주기를

명령어 사이클이라고 해요 예를 들어서

cpu가 메모리에 있는 어떤

프로그램을 실행한다라고 한번 가정을

해 볼게요

그러기 위해서 일단은 cpu는 어떤

작업을 해야 될 것 같아요

인출을 해야겠죠

메모리에 있는 값을

cpu에 레지스터 혹은 CPU 내부로

갖고 와야겠죠 갖고 와야지

실행하니까요 그렇죠 이렇게

cpu가 메모리 안에 있는 어떤

프로그램을 실행하기 위해서 메모리에

저장된 값을 CPU 내부로

갖고 오는 작업을

인출이라고 합니다 그리고 이런 식으로

인출을 하는 주기를

<mark style="background: #FF5582A6;">인출 사이클</mark>이라고 부릅니다

갖고 왔으면 어떻게 해야 되겠어요

갖고 왔으면 실행해야겠죠

그렇죠 이거를

<mark style="background: #FF5582A6;">실행싸이클</mark>이라고 합니다 일반적으로

cpu는

인출 실행

인출 실행이 인출 사이클과

실행싸이클이 반복되면서 실행됩니다

메모리로부터

실행할 거를 갖고 오고

실행하고

갖고 와서 실행하고 갖고 와서

실행하고이 과정이 반복되요 이게

명령어 사이클의 일부라고 보시면

됩니다

인출사이클

실행 사이클

어렵지 않죠 그렇죠 자 근데 앞서

제가

이런 이런 명령어 주소지정 방식도

있다라고 말씀드렸죠

인출을 하면 바로 실행이 가능한

명령어도 있지만

고 소개를 해

드렸었어요

그렇죠 자 이런 경우에 즉 인출을

했다고 해서 바로 실행이 불가능하고

몇 번 더 메모리 접근을 해야 되는

경우를 위해서 이런 식으로 간접

사이클이 추가될 수 있습니다

인출을 했는데 인출 사이클이 끝나고

바로 실행이 가능한 경우도 있지만

인출을 한 다음에

메모리 접근이 더 필요한 경우에는

간접 사이클에 돌입하게 됩니다 그리고

간접 사이클이 끝나고 마침내 실행이

가능하게 되면

실행사이클로 주도록 하는 거죠

몇 가지 이해가셨죠 그쵸 자 이게

명령어 사이클의 1부입니다 근데

여기서 보통 일반적으로는 인터럽트라고

하는 개념이 없다면

cpu는이 주기를 바탕으로 실행됩니다

이것만으로도 이제 실행이 돼요이

주기를 바탕으로

근데 여기서 인터럽트라고 하는 개념이

생깁니다

인터럽트는 이러한 정해진 흐름대로

cpu가 막 프로그램을 처리하고

있는데 이런 정해진 흐름을

끊어버리는게 인터럽트라고 해요

몇 가지 이해하셨죠

인터럽트는 여러분들이 프로그래밍을

하시다 보면은

분명히 자주 접하게 되는

단어 중에 하나일 겁니다 인터럽트

키보드 인터럽트 뭐 이런 식으로요

인터럽트는 영어로 방해하다 중단시키다

이런 걸 의미합니다

cpu가 이런 정해지는 흐름대로

명령어들을 처리하고 있는데이 정해진

흐름을 방해하는 신호가 바로

인터럽트인 것이죠

cpu가 실행하는 정해진 흐름을

끊는게 인터럽트니까이 인터럽트는 언제

발생하겠어요 그냥 아무 때나 발생해도

되겠어요 안 되겠죠

cpu가 꼭 주목해야 될 때

cpu가 얼른 처리해야 되는 작업이

생겼을 때 보통 이럴 때 인터럽트가

발생합니다

회사에서도 이런 일이 많이 있죠

강 대리 지금 하고 있는 거 잠깐만

잠깐만 중단하고 이거 급한 거니까

이거 먼저 처리해 줘 이런 식으로

일을 하잖아요 그렇죠 이런게 바로

인터럽트라고 보시면 됩니다

개념은 좀 이해가 되시죠 그쵸

인터럽트의 종류에는 사실

동기 인터럽트 예외라고도 불러요

익셉션 비동기 인터럽트 하드웨어

인터럽트라고도 불러요

인터럽트의 종류에는

크게<mark style="background: #FF5582A6;"> 동기인 트럭트와 비동기

인터럽</mark>트가 있는데요 예외

익셉션과 하드웨어 인터럽트가 있는데요

이번 시간에 주로 다룰 것은 하드웨어

인터럽트입니다

그러니까 동기 인터럽트부터 알아볼게요

동기인터럽트 예외라고 했죠

익셉션 영어 익셉션이라고 더 많이

써요 이거는

언제 발생하냐면

cpu가 예기치 못한 상황을 접했을

때 발생해요 어이 예외적인 상황은

뭐지

잠깐 실행을 중단하고

이 주기대로 이제 실행을 쭉 하고

있었는데

잠깐

멈추고이 예외적인 상황을 먼저

처리해야겠다라고 cpu가인지를 하는

거죠 이게 비동기 인터럽트라고 합니다

뭐 cpu가 접근하고자 하는 메모리

주소에 딱 접근했는데 원하는 데이터가

없다던지 아니면 뭐 디버깅을 위해서

디버깅을 할 때도 그것도 인터럽트의

종류거든요 뭐 디버깅을 한다든지

아니면 뭐 0으로 나눈다든지 뭐 이런

식으로 아니면 실행할 수 없는

명령어가 있다든지 뭐 그런 경우에

발생하는 인터럽트가 다 예외 동기

인터럽트라고 보시면 됩니다

참고로 동기 인터럽트의 종류에는요

다른 전공서의 표현을 빌리자면 폴트

트랩 중단 어보트라고도 해요 중단은

소프트웨어 인터럽들이 4가지 종류가

있습니다

근데 이번 시간에는이 동기 인터럽트

즉 예외에 대해서 자주 다루지는 않을

거고요 이런 종류가 있다

정도로만 이해하시면 되겠습니다이 동기

인터럽트에 대해서는 추후 운영체제에서

조금 더 자세하게 다룰 예정이니까요

아시겠죠

자 비동기 인터럽트 즉 하드웨어

인터럽트는 뭐냐면요 주로 입출력

장치에 의해서 발생하는 하드웨어

다른 하드웨어가 보내주는 인터럽트라고

보시면 됩니다

동기 인터럽트가 cpu가 예기치 못한

상황을 접했을 때 발생한다고

말씀드렸죠

근데 비동기 인터럽트는

어떤 문제라기보다는 알림과 같은

역할이라고 보시면 편이에요 알림

세탁기가 완료되면 알림이

띠링띠링하고 올리죠 그쵸 또

전자레인지가 조리가 완료되면 또

띠링띠링하고 올리죠 그쵸 자 이런

알림고 같은 역할을 하는게 바로

하드웨어 인터럽트 비동기 인터럽트라고

보시면 됩니다

cpu가 예를 들어서 뭐 프린터한테

프린트 하고 있어 난 다른 일하고

있을테니까

입출력자가 완료되면 다시 불러줘라고

하고

출력 작업이 다 완료가 되면은

cpu한테 알림과 같은 하드웨어

인터럽트를 보내는 거죠 이런 식으로

자 이렇게 사용되는 것이 바로 비동기

인터럽트 하드웨어 인터럽트라고 보시면

됩니다

아시겠죠 비단 프린터뿐만 아니라 다른

입력 장치도 마찬가지입니다 여러분들이

키보드에다가 어떤 값을 입력하거나

마우스로 클릭을 하는 것도 전부 다

인터럽트의 한 종류라고 볼 수

있는데요 만약에 여러분들이 키보드

혹은 마우스를 누르게 되면 거기서부터

발생한 알림과 같은 역할을 하는

하드웨어 인터럽트가

cpu한테 전달이 됩니다 그럼

cpu가 그것을 인지하고 아 이런

입력이 들어왔구나 이제 이런 입력을

처리해 줘야겠다라는 식으로 행동을

하게 될 거예요 정해진

어떤 흐름을 중단하고

몇 가지 이해가 되셨죠 그렇죠 자

이걸 조금만 더 자세하게 알아봅시다

비동기 인터럽트에 대해서 조금 더

자세하게 알아볼게요 자 하드웨어

인터럽트는 앞서 말씀드렸다시피 세탁기

완료 알림이나 전자레인지 조리 완료

알림처럼 알림음과 같은 인터럽트라고

말씀을 드렸습니다이 하드웨어

인터럽트라고 하는게 도대체 왜

존재하느냐 이걸 왜 쓰느냐라고 한다면

cpu가

입출력 작업 도중에도

효율적으로 명령어를 처리하기 위해서

사용합니다이 말에 대해서 조금 이해를

하실 필요가 있는데요

입출력 장치의 입출력 작업은

일반적으로

cpu에 비해서 느립니다 만약이

하드웨어 인터럽트가 없다면 만약에

cpu가

프린터기한테

입출력 명령 뭐 프린트를 해라 뭐

이런 식으로 명령어를 내렸을 때

cpu는 프린트 완료 여부를 확인하기

위해서 주기적으로 완료 여부를 확인을

해줘야 됩니다 다 됐나 아니네 다

됐나 아니네 다 됐나 아니네 뭐 이런

식으로요이 인터럽트가 없는 경우의

상황입니다

근데 인터럽 없다면 나 다른 일하고

있을테니까 완료되면 알림 알림으로

알려 줘 뭐 이런 식으로

다른 일을 할 수가 있는 거죠

cpu가

그렇죠

입출력 작업이 끝나면 그때야 비로소

이제 하던 일을 잠깐 중단하고 확인을

하면 되는 거니까요

여기까지 이해하셨죠 하드웨어

인터럽트를 왜 사용하는지 아시는게

중요합니다 자

그렇다면 이러한 하드웨어 인터럽트는

어떤 순서대로 내부적으로 어떤 식으로

처리되느냐에 대해서 말씀드릴게요 사실

하드웨어 인터럽트라고 쓰기는 했지만

인터럽트의 종류를 막론하고 대부분의

인터럽트를 처리하는 순서는 여기

아래에서 크게 벗어나지 않습니다

아시겠죠 일단은

쭉 한번 읽어 볼게요 여기에 대해서

모르시는 용어들은 제가 다 설명 드릴

거예요


<mark style="background: #FF5582A6;">인터럽트 처리순서</mark>  
👉 입출력 장치는 cpu한테 인터럽트 요청 신호를 보냅니다  
👉그리고 cpu는 실행 사이클이 끝나고 명령어를 인출하기 전에 항상 인터럽트가 있었나 인터럽트를 받아들일 수 있었나 뭐 이런 식으로  
인터럽트 여부를 확인합니다  
👉그리고 cpu가 인터럽트 요청을 확인하면 어 이런 알람이 있었네 어 이런 알림이 있었네 이런 식으로 인터럽트 요청을 확인을 하면은  
👉플래그 레지스터에 있는 인터럽트 플래그를 통해서 현재 인터럽트를 받아들일 수 있는지이 인터럽트를 지금 처리할 수 있는지 여부를 확인을 합니다 만약에 이런 것들이 처리할 수 있다면 cpu는 지금까지 했던 작업을 잠시 백업을 하고요  
👉 인터럽트 벡터를 참조해서 인터럽트 서비스 루틴이라고 하는 프로그램을 실행합니다 이거 다 무슨  
👉 인터럽트 서비스 루팅 실행이 끝나면 여기서 백업해둔 잠시 백업해둔 그 작업을 복구해서 다시 하던 일을

실행을 제기합니다 이게 인터럽트의

처리 순서라고 보시면 돼요 아시겠죠

근데 여기서 모르는 용어들이 좀

있었죠 이런 용어들을 아직 잘 모르실

겁니다

그렇죠

인터럽트 요청 신호

인터럽트 플래그 인터럽트 벡터

인터럽트 서비스 루틴 이거에 대해서

이제부터 하나씩 말씀드리도록 할게요

아시겠죠

<mark style="background: #FF5582A6;">인터럽트 요청 신호</mark>는 뭐냐면 하드웨어

인터럽트를 보내는 주체들 있죠 이런

하드웨어 인터럽트를 보내는 입출력

장치 같은 주체들이

<mark style="background: #FF5582A6;">cpu한테 지금 끼어들어도 돼요라고

요청을 보내는 신호를

인터럽트 요청 신호</mark>라고 부릅니다

인터럽트는

cpu의 정상적인 실행 흐름을 끊는

거기 때문에

항상 이런 식으로 인터럽트를 보내는

주체는 인터럽트 요청 신호를

cpu한테 보내게 됩니다 지금

끼어들어도 돼요 지금 이거 처리해 줄

수 있어요 이렇게 요청을 보내는

신호가 바로 인터럽트 요청 신호라고

보시면 됩니다 아시겠죠

그리고 이런 식으로 cpu와 인터럽트

요청 신호를 받아들였으면

실행 사이클이 끝나고

항상

플래그 레지스터 속에 인터럽트

플래그를 확인을 합니다이 <mark style="background: #FF5582A6;">인터럽트

플래그에는

현재 인터럽트를 받아들일 수 있다

현재 인터럽트를 받아들일 수 없다 뭐

0과 1 뭐 이런 식으로 표기가 될  
</mark>  
거예요 만약에 인트로트 플래그가

현재 인터럽트를 받아들일 수 있는

상태라면

cpu는 해당 인터럽트 요청을

받아들이고 인터럽트를 처리하게 되고요

만약에 인터럽트를 받아들일 수 없는

상태라면

인터럽트 요청 신호가 이렇게 오더라도

해당 인터럽트는 처리하지 않습니다

다만 여기서 유의하셔야 될 점은

<mark style="background: #FF5582A6;">뭐냐면 모든 인터럽트를 인터럽트

플랙으로 막을 수 있는 것은 아닙니다

일부 인터럽트 중에서는 하드웨어

고장이라든지 정전이라든지 이런 어떤

꼭 처리해야 되는 이거는 안 처리하면

안 되면 안 되는 너무 중요하고

긴급한 인터럽트도 있거든요 그런

것들은

인터럽트 플래그로 막을 수가 없습니다</mark>

현재 인터랙트를 받아들이지 않겠다로

설정이 되어 있어도

그러한 종류의 인터럽트는

막을 수가 없어요 이렇게 인터럽트

플랙으로 막을 수 없는

인터럽트를

<mark style="background: #FF5582A6;">넌 마스크브 인터럽트 nmi라고도

합니다 아시겠죠

요컨데 비동기 인터럽트는

막을 수 있는 인터럽트와 막을 수

없는 인터럽트라고 생각하셔도 돼요</mark>

다만 대부분의 입출력 장치가

cpu한테 보내는 하드웨어 인트로트는

대부분 인터럽트 플래그를 통해서 막을

수가 있습니다 아시겠죠 이것들은 뭐

하드웨어 고장이나 정전 같이

정말 긴급한 상황이나

피치 못한 사정에서

막을 수 없을 정도로 긴급한 상황에서

발생하는 인터럽트라고 보시면 돼요

아시겠죠 자 그리고 cpu가

인터럽트를 받아들이기로 했다면

<mark style="background: #FF5582A6;">인터럽트 서비스 루틴</mark>이라고 하는

프로그램을 실행합니다

인터럽트 서비스 루틴은

프로그램이에요

메모리 안에서

실행되는 프로그램입니다

<mark style="background: #FF5582A6;">인터럽트 서비스 루틴은

인터럽트가 발생했을 때 해당

인터럽트를 어떻게

처리하면 되는지가 적혀 있는

프로그램이라</mark>고 보시면 됩니다 예를

들어서

키보드가

요청을 보내면 이렇게 행동하세요

마우스가 인터럽트 요청을 보내면

이렇게 행동하세요 이런 것들이 적혀

있는

프로그램을

인터럽트 서비스 루틴이라고 합니다

인터럽트 서비스 루틴 또한

프로그램이기 때문에 일반적으로

메모리에 저장되어 있습니다 그리고

인터럽트를 보내는 주체에 따라서

각기 다른 인터럽트 서비스 루틴의

시작 주소를 가지고 있어요 뭐 예를

들어서 이거는

프린터기의

인터럽 서비스 루틴 프린터기가 어떤

인터럽트를 딱 보내면 해당 인터럽트를

이렇게 처리한다가 적혀 있는 프로그램

뭐 여기에는

키보드의 인터럽트 서비스 루틴

키보드가 어떤 인터럽트를 보내면 그

인터럽트를 어떻게 처리해야 된다라는

정보가 적혀있는 프로그램이 저장되어

있을 수 있고요 뭐 여기에는 마우스의

인터럽트 서비스 루틴 마우스가 어떤

인터럽트를 보내면

cpu는 어떻게 처리해야 된다 뭐

이런 정보가 적혀 있는 프로그램 이런

식으로

인터럽트를 보낼 수 있는 주체에

따라서

각기 다른 인터럽트 서비스 루틴을

갖고 있어요

몇 가지 이해가 졌죠 그렇죠 cpu는

자기가 실행 중인 프로그램을 이런

식으로 쭉 실행을 하다가 만약에

인터럽트가 땅 발생을 하면은 해당

명령어까지는 실행을 끝내고 그

인터럽트로 도달아서 되돌아가서 그

인터럽트를 실행한 다음에 다시

되돌아와서 수행을 제기하게 됩니다

이런 식으로 이거를 그림으로 표현하면

이렇게 표현할 수가 있어요 만약에

인터럽트가 없다면

인터럽트가 없이 실행된다면 정상적으로

실행이 된다면 그냥

실행하는 프로그램을 쭉 실행하면

됩니다

근데 만약에 인터럽트가 도중에 발생을

했어요 여기까지 쭉 실행하려고 했는데

여기서 인터럽트 요청 신호가 딱

발생을 했고

cpu가 인터럽트를 받아들이기로

했다면 여기서 처리하는 명령까지는

처리를 한 다음에 그 인터럽트에

해당하는 인터럽트 서비스 루틴으로

점프를 합니다 그리고 그 인터럽트

서비스 루틴을 쭉 실행을 하고 아까

전에 점프했던 곳으로 되돌아간 다음에

다시 수행을 재개합니다 이런 식으로

인터럽트가 처리된다라고 보시면 돼요

몇 가지 이해가 좋죠 그쵸 자 근데

앞서 말씀드렸듯이 인터럽트를 보낼 수

있는 주체가 여러 개가 있죠 프린터도

cpu한테 인터럽트를 보낼 수 있고요

마우스도 마찬가지고 키보드도

마찬가지입니다 이것들 모두가

각기 다른 인터럽트 서비스 루틴

주소를 갖고 있어요 <mark style="background: #FF5582A6;">다시 말해서

인터럽트마다

고유한

인터럽트 서비스 루틴의 시작 주소를

가지고 있습니</mark>다 예를 들어서 만약에

얘가 키보드의 인터럽트 서비스

루틴이었다면

키보드 인터럽트 서비스 루틴의 시작

주소는 여기겠죠 그럼 cpu는

키보드 인터럽트가 발생하면은

여기서부터 그냥 쭉 여기까지 실행을

하면 되겠죠 마찬가지로 만약에

프린터기의 인터럽트 서비스 루틴

주소가 여기였다면

시작 주소가 여기였다면

cpu는 여기서부터

쭉 실행을 하면 되겠죠 여기까지

그렇죠 이게 만약에 마우스 인터럽트

서비스 루틴이었다면

cpu는 마우스 인터럽트에 대해서

여기서부터

쭉 실행을 하면 되겠죠

그렇죠 자 이렇게 인터럽트를 보낼 수

있는 주체에 따라서 인터럽트 서비스

루틴의 시작 주소가 달라질 수 있는데

<mark style="background: #FF5582A6;">cpu가 해당 인터럽트 서비스 루틴의

시작 주소는 무엇인지 그 인터럽트를

구분할 수 있는 정보가 필요하겠죠

그쵸 자 그렇게

각각의 인터럽트를

구분하기 위한 정보를

인터럽트 벡터</mark>라고 부릅니다 몇 가지

이해가셨죠 그렇죠

인터럽트 벡터를 통해서 아

인터럽트 배터리 보아하니까이 인터럽트

서비스 루틴의 시작점은 여기구나

여기서부터 실행하면 되겠구나 지금

여기서 쭉 되돌아왔는데 여기로 그냥

점프하면 되겠구나를 알 수가 있는

거죠이 <mark style="background: #FF5582A6;">인터럽트 벡터를 통해서

쭉 모아놓은

표의 형태로 모아놓은 인터럽트

벡터들을

표처럼 모아놓은

인터럽트 벡터 테이블</mark>이라고 하는 것도

여기 있습니다 메모리에 아시겠죠

어쨌든

인터럽트 벡터란

각각의 인터럽트를

구분하기 위한 정보

식별하기 위한 정보다 그리고 이걸 왜

필요하냐면

<mark style="background: #FF5582A6;">cpu가 해당 인터럽트 서비스 루틴의

시작 주소를 알기 위해서

인터럽트 벡터를

필요로 한다라고 이해하시면 됩니다

보통 인터럽트를 보내는 주체는요 해당

인터럽트와 함께 인터럽트 요청 신호와

함께 인터럽트 벡터도 데이터 버스를

통해서 보내게 됩니다

이것도 그냥 참고서 말아주시면 될 것

같아요 아시겠죠  
</mark>  
요컨대 cpu가 인터럽트를

처리한다라고 하는 말은 달리 말하면

인터럽트 서비스 루틴을 실행하고

원래 수행하던 작업으로

되돌아온다라고도

표현할 수 있어요 그리고 인터럽트

시작 주소는 인터럽트 벡터를 통해서

알 수 있다 이렇게 알게 된 시작

주소에 있는 프로그램을

실행하고 즉 인터럽트 서비스를

실행하고

원래 작업으로 되돌아온다라고 보시면

돼요 자 근데 여기서 문제가 있습니다

cpu가 실행 중인 프로그램을 쭉

실행하다가 인터럽트가 발생하면 해당

인터럽트 서비스 루틴으로 점프해서

마저 실행하고 되돌아온다라고 말씀을

드렸죠 그쵸 근데이 프로그램을

실행하는 과정에서도

프로그램 카운터 뭐 이런저런 레지스터

안에 이런 레지스터 값들이 지금 이미

cpu1에 저장되어 있을 거 아니에요

그쵸 이런 것들을 지금 어떻게 해야

될까 이런 것도 그냥 버려 버리면

될까요

인터럽트 서비스 루틴을 실행하게 되면

만약에 10번지에 있는 인터럽트

서비스 루트는 실행하면 이것들을

프로그램 카운터라고 한다면

1,500을 10으로 바꿔야겠죠

그렇죠 근데이 1,500이라고 하는이

값 있죠

다음 실행할 명령어는

1500번지야라고 하는 이런 레지스터

값들을 그냥 버려 버리면 될까요

그럼 안 됩니다 왜냐면 언제든 다시

되돌아와서 수행을 재개해야 되기

때문에

현재 레지스터에는 어떤 값들이

담겨있는지

현재 이제 cpu는 어떤 상태인지가

다 기억이 되어 있어야 돼요 그렇기

때문에

인터럽트로 점프하는 것은 좋은데 그

전에 그 전에 지금까지 했던 작업을

어디다가 백업을 한 다음에 그 다음에

인터럽트 서비스로 등을 실행하면서

이런저런 레지스터 값들을 사용을 해야

됩니다

인터럽트 서비스 루틴도 프로그램이니까

당연히 이런저런 레지스터를 쓸 거

아니에요 그쵸

근데 그 전까지 있었던 레지스터들은

어딘가에 백업을 해둬야 된다고요

여기까지 이해 가시나요

그렇죠 자 이러기 위해서 <mark style="background: #FF5582A6;">그걸 위해서

백업을 하기 위해서 지금까지의 작업

내용 이를테면 뭐 레지스터 안에 담겨

있는 이런 값들은 전부 다

스택에 백업을 해두게 됩니다 그  
</mark>  
다음에 인터럽트 서비스 루틴을 위해서

이제

레지스터를 쓸 수가 있는 거죠 이런

식으로 그럼 이제 인터럽트 서비스

루틴을 실행하기 위한

어떤 정보들이

레지스터 안에 담기게 되고 가령

프로그램 카운터에는 10 11 12

이런 식으로 담길 수가 있겠죠 그쵸

자 만약에 인터럽 서비스 루틴에

실행이 끝났다라고 하면은 다시 이거를

쭉

복구를 해서 다시

프로그램 카운터 값은 1500이야

메모리 주소 레지스터에는 이런 값이

있었고 뭐 범용 레지스터에는 이런

값이 있었어 뭐 이런 식으로 다시

스택에서

백업을 해오게 됩니다

그러면

다음

다음 실행할 명령어가 어딘지 알 수

있겠죠 그쵸

곧바로 다음으로 실행할 명령어부터

쭉 수행을 제기할 수가 있겠죠 그죠

인터럽트가 발생하면은 지금 상태를

백업하고 해당 인터럽트 서비스로 진에

해당하는 것들을

쭉 cpu로 갖고 와서 실행을 하게

된다라고 보시면 됩니다 자 그럼

정리를 해보겠습니다

인터럽트를 처리하는 순서는 다음과

같다고 말씀드렸죠

입출력 장치는

cpu의 인터럽트 요청 신호를 보낸다

인터럽트 요청신호란

cpu의 작업을 방해하는 인터럽트를

보내도 되는지에 대한 요청이다라고

말씀을 드렸고요 그리고

cpu는 실행싸이클이 끝나고 명령어를

인출하기 전에

인터럽트가 있었나 알람이 있었나 이런

여부를 항상 확인합니다 그리고

인터럽트 요청이 만약에 있었다면

인터럽트 플래그를 통해서

현재 인터럽트를 받아들일 수 있는지

없는지를 확인합니다이 인터랙터

플래그는 플래그 레지스터 안에 있는

플래그 값 중에 하나라고 말씀을

드렸죠 그리고이 인터럽트 플래그를

통해서

현재 인터럽트를 처리할 수 있다

없다를 판단할 수 있다라고

말씀드렸어요

참고로

인터럽트 플래그를 통해서 막을 수

없는 인터럽트도 있다

라고 말씀을 드렸습니다

덧붙

여서 끝까지 이해가셨죠 그쵸 그리고

인터럽트를 받아들일 수 있다면

cpu는 지금까지의 작업을 백업합니다

이런 식으로요

그래야지 나중에 이걸 복구해서 수행을

재개할 수가 있으니까요

그렇죠 그리고 cpu는 인터럽트

벡터를 참조해서

인터럽트 서비스 루틴을 실행합니다라고

써 있는데

인터럽트 벡터란 인터럽트 서비스

루틴의 시작 주소를 포함하는

인터럽트의 식별 정보라고 보시면

되고요 인터럽트 서비스 루트는

인터럽트를 처리하는 프로그램이다라고

말씀을 드렸습니다 이렇게 쭉

인터럽트를 처리한 다음에

실행이 끝나면

백업한 것들을

복구해서

실행을 제기한다 이게 인터럽트의 전체

과정이라고 보시면 됩니다

어렵지 않죠 그렇죠

자 그럼 인터럽트가 발생한 상황까지

추가한 명령어 사이클은 이렇게 그릴

수가 있습니다

실행싸이클이 끝나고

인터럽트 여부를 확인했는데 만약에

인터럽트가 발생했을 경우에 인터롭스

사이클이 이렇게 추가된다라고 보시면

돼요

여기까지 이해가셨죠 그쵸 자 cpu는

결국 메모리에 있는 프로그램을 이러한

주기에 맞춰서 이러한 어떤 정형화된

흐름에 따라서

처리한다 이게 명령어 사이클이다라고

보시면 되겠습니다

여기까지 이해가 됐죠 그렇죠

자 이번 강의는 여기까지 진행하도록

하겠습니다

감사합니다