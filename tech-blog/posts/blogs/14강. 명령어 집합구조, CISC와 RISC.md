
```ad-note
title: 키워드
- 명령어 파이프라이닝
- 명령어 집합 
- CISC
- RISC
```

```ad-question
title: 
- 
```

안녕하세요 강유철입니다 자 이번

시간에는

<mark style="background: #FF5582A6;">명령어 집합 구조 그리고

시스코와 리스크</mark>에 대해서

말씀드려보도록 하겠습니다 이전

영상에서

명령어 병렬처리 기법 중에 하나인

명령어 파이프라이닝에 대해서 말씀을

드렸는데요이

명령어 파이프라이닝 그리고 명령어

병렬처리 기법은

현대 cpu가

꼭 사용해야 되는 아주 중요한 핵심

기술이라고도 볼 수 있습니다

근데 여기서 이런 질문을 드리고

싶어요

명령어 파이프라이닝을 하기 유리하게

생긴 명령어가 있고요

명령어 파이프라이닝에 불리하게 생긴

명령어가 있거든요 자 그렇다면

명령어가 어떻게

생겨야지

명령어 파이프라이닝에 유리할까요

명령어 파이프라이닝에 유리한 명령어는

어떻게 생겼을까요

자 여기에 대해서 알아보도록

하겠습니다

자 명령어 집합의 개념에 대해서 먼저

말씀을 드릴게요

cpu는 명령어를 실행한다라고 제가

말씀을 드렸죠

<mark style="background: #FF5582A6;">근데이 세상에 있는 모든 cpu가 다

똑같이 생긴 명령어들을 실행할까요

그건 아닙니다 왜냐하면

CPU 제조사별로도 만드는 cpu가

다르고요 그리고 같은 제조사에서 만든

cpu라고 할지라도

명령어의 세세한 생김새나 뭐 연산

방식 주소지정 방식은

cpu마다 다른 경우가 있어요 다시

말해서

cpu마다 이해하는 명령어의 종류가

다른 경우가 있습니다</mark>

👉 명령어 집합 그리고 명령어 집합 구조는  =  cpu가 이해할 수 있는 명령어들의 모음을 의미한다라고 보시면 

됩니다 예를 들어서

인텔의 cpu가 이해할 수 있는

명령어들의 집합이 있고 그리고 아이폰

cpu가 이해할 수 있는

명령어들의 집합이 있다라고 보시면

됩니다

그렇기 때문에

그렇기 때문에

인텔 데스크탑 컴퓨터에서

실행 파일을 만들고 그 실행 파일을

그대로 아이폰이나 맥북으로 옮겨서 뭐

특별한 설정 없이 바로 그 exe

실행 파일을 실행하면은

실행이 안 될 수밖에 없는 거예요

왜냐하면

인텔에서 이해하는 실행 파일 즉 실행

파일은 명령어라고 말씀드렸죠

명령어들의 모음으로 만들어진 파일이

실행 파일이다라고 말씀드렸죠 다시

말해서

인텔 cpu에서 이해하도록 만들어진

실행파일 즉 명령어들의 모음을

아이폰이나 맥북으로 그대로 옮기면

이해할 수 있는 명령어가 아니기

때문에 실행이 안 되는 거예요 다시

말해서

cpu는

명령어 집합에 속해 있는 명령어들만

이해할 수가 있습니다

여기까지 이해하셨죠 그쵸 이거 혹시

기억하시는 분들 계실까요 제가

명령어 파트에서

고급 언어와 저급 언어에 대해서

말씀드렸을 때<mark style="background: #FF5582A6;"> 같은 소스 코드를

컴파일 하더라도

cpu의 종류에 따라서 어셈블리어의

종류로 달라질 수 있다</mark>라고 제가

말씀을 드렸던 거 혹시 기억하세요 자

이게 왜 달라지는 거냐면

지금

명령어 집합이 달라지면 이거

어셈블리어가 한 주 한 줄도 이제

명령어라고 말씀드렸죠 그렇죠 예를

들어서 x86 cpu에서는 이러한

명령어들을 이해할 수 있기 때문에이

소스 코드를 컴파일 하게 되면은

적금 언어 코드가 만들어지는 거고요

암 CPU 같은 경우에는

암 cpu는 이러한 명령어가 아니라

이렇게 생긴 명령어들을 이해하는

cpu기 때문에 같은 소스 코드를

컴파일 할지라도 이러한 명령어들을

담고 있는 적금 언어들이 나오게 되는

거예요

자 명령어 집합이 다르기 때문에 같은

소스 코드를 컴파일 할지라도 나오게

되는

명령어 혹은 어셈블리어 기계어의

종류가 다를 수 있다까지 말씀드렸어요

달리 말해서

<mark style="background: #FF5582A6;">x86 혹은 x86 64 명령어

구조를 따르는 cpu들은

얘네들 말을 이해를 못하고요

암 명령어 집합을 따르는 cpu들은

얘네들의 말을 이해할 수가 없어요

그렇기 때문에 당연히 실행도 안 되는

거죠 아시겠죠 자</mark> 이런 관점에서

보면은

명령어 집합 혹은 명령어 집합 구조는

cpu들의 언어인셈입니다 근데

각기 다른 언어를 사용하는 나라들을

보면 그냥 말만 다른게 아니라 그냥

사용하는 언어만 다른게 아니라

언어에 따라서 사람들의 가치관이나

생활 양식도 달라지는 것을 볼 수가

있습니다 예를 들어서 우리나라 같은

경우에는 높임말이 있으니까 비교적

어른을 공경하는 문화가 있고

높임말이 없는 나라에서는 비교적

평등한 문화가 자리잡힌 것처럼요

사실 잘 몰라요 왜냐하면 여권도

없거든요 아무튼 말만 달라지는게

아니라 말에 따라서 생활습관이나

양식도 달라진다라고 하는 점을 알고

있죠 그쵸

<mark style="background: #FF5582A6;">cpu도 마찬가지입니다

명령어가 달라지면 명령어의 종류가

달라지면 그에 대한 나비효과로 많은

것들이 달라질 수가 있어요

명령어 해석하는 방식이라든지

레지스터의 종류나 그 개수라든지

파이프라이닝이

쉽거나 혹은 어렵다든지 이런 것들이

아주 많이 달라집니다 그렇기 때문에

명령어 집합에 따라서

cpu의 구조 나아가서 컴퓨터의

구조까지도 결정이 되기 때문에

명령어 집합 명령어 집합

구조라고도 부르게 되는 거예요 이걸

명령어 집합 구조는

isa</mark>라고도 부릅니다

ISA

instruction set

아키텍처의 줄임말이에요 아시겠죠

어쨌든

명령어가 달라지면 그에 대한

나비효과로 많은 것들이 달라지기

때문에 이걸 명령어 집합 구조라고도

부른다까지 이해하시면 되겠습니다

아시겠죠 다시 말해서 <mark style="background: #FF5582A6;">명령어의 집합이

달라지면 그 명령어를 조금 더

효율적으로 실행할 수 있는 하드웨어

구조도 달라지기 때문에

ISA 즉 명령어 집합 명령어 집합

구조는 하드웨어가 소프트웨어를 어떻게

이해해야 될지에 대한 약속</mark>이기도

합니다

여기까지 이해가셨죠 그쵸 예를 들어서

이렇게 생긴 명령어들을 실행하기

편하게 만들어진 하드웨어도 있을 거고

이렇게 생긴 명령어를 실행하기 편하게

만들어진 하드웨어도 있겠죠

그렇죠

그렇기 때문에

isa는 소프트웨어와 하드웨어 사이의

약속이다라고 보는 관점도 있습니다

아시겠죠 자 그렇다면 이번 시간에는

이러한 <mark style="background: #FF5582A6;">명령어 집합에 가장 큰 두

개의 카테고리 가장 큰 두 개의

종류인

시스코와 리스크</mark>에 대해서 학습해

보겠습니다이 시스코와 리스크는 현대

명령어 집합의 이제 가장 커다란 두

개의 종류 가장 대표적인 두 개의

종류라고 보시면 돼요 일단

시스크부터 말씀드릴게요 시스크는이

뜻을 한번 짚어보시면 이해하는게

그렇게 어렵지 않습니다이

<mark style="background: #FF5582A6;">👉 시스크는 컴플렉스 인스트럭션 셋 컴퓨터라고 하는 말에 준말이거든요 자 컴플렉스 인스트럭션
셋 컴퓨터는 어떤 말이냐면 한국말로 번역을 하면은 복잡한 명령어 집합을 활용하는 컴퓨터 여기서 컴퓨터는 cpu라고도 이해하셔도 돼요 어쨌</mark>든

복잡한

명령어 집합을

활용한다라고도

볼 수 있습니다 자 인텔이나

amd사의 cpu로 대표되는

x86이나 x86 64는 다 이스크

복잡한 명령어 집합을 활용하는 이런

집합 구조를 기반으로 두고 있다라고

이해하시면 됩니다이 시스크는

복잡한 명령어 집합을 사용하기 때문에

복잡하고 다양한 명령어들을 사용합니다

명령어의 크기와

형태가 다양하고요 이거를 가변 길이

명령어라고도 합니다 예를 들어서 어떤

명령어는 뭐 이런 뭐 되게 독특한

기능을 수행하는 명령어도 있고요 뭐이

어떤 독특한 주소지정 방식을 지원하는

명령어도 있고요 자 이렇게

복잡하고

<mark style="background: #FF5582A6;">명령어 수 자체도 다양하고 이런

어떤 가변 길이 명령어 집합을

활용한다라고 보시면 되겠습니다

이 명령어 하나하나가 굉장히

강력한 기능들을 제공하고 그리고

이러한 명령어 자체도 그 개수도

다양하기 때문에 상대적으로

적은 수의 명령어로도

프로그램을 실행할 수가 있습니</mark>다 예를

들어서

이러한 소스 코드를 컴파일 했을 때

이러한 명령어들이 쭉 이렇게 나오죠

컴파일 했을 때 그쵸 근데 이러한

명령어 하나하나가

강력한 기능들을 제공하고 그리고

하나의 명령어 종류 자체도 다양하기

때문에 이렇게 컴파일에서 나온

결과적으로 나온

명령어의 숫자도 명령어의 개수도

적다는 거죠

여기까지 이해하셨죠 그렇기 때문에

상대적으로

적은 수의 명령어로도 프로그램을

실행할 수 있다라고 이해하시면

되겠습니다 뭐 소스코드를 컴파일하면

강력하고 가변 길이의 명령어가

결과로서 나오게 된다 그리고 그

숫자는

적다 상대적으로 이렇게 이해하시면

돼요

근데 여기까지 들으면 어때요

시스크가 굉장히 좋아 보이죠 그쵸

<mark style="background: #FF5582A6;">실제로 시스크가

메모리를 최대한 아끼면서 개발해야

했던 시절에 인기가 높았는데 이게 한

가지 단점이 있습니다

명령어 파이프라이닝이 불리하다는

단점이 있어요이 단점이 중요합니다

명령어 하나하나가 워낙에 복잡하고 또

다양한 기능들을 제공하기 때문에

명령어의 크기나 하나하나의 명령어 그

개별적인 크기나

명령어 하나가 실행되기까지의 시간이

일정하지 않습니다 그리고

복잡한 명령어 때문에 이렇게 막

하나하나 이제 강력한 명령어들을

지원하고 또 독특한 주소지정 방식도

있기 때문에 하나의

복잡한 명령어를 실행하는데

여러 클록 주기가 필요하게 되는

경우가 많

자 이런 경우에는

파이프라이닝이 불리합니다</mark>

파이프라이닝이 잘 되려면 어떻게 해야

되냐면이 명령어가 실행돼야 되는이

하나의 시간이 비교적 정형화 되어

있어야 됩니다 가급적 한 클럭 주기로

탁탁탁탁

실행이 돼야 되고

착착착

명령어의 길이나

실행 시간도

들쑥날쑥하지 않아야지 이렇게

명령어들이 겹쳐서 실행하는

파이프라이닝이 제대로 동작을 하겠죠

그쵸

근데

명령어 하나하나당 이제 실행해야 되는

시간이 이렇게 들쑥날쑥하면은

당연히 파이프라인이 불리할 수밖에

없겠죠 어떤 명령어는 실행하는데 뭐이

클럭이 소요되고 어떤 거는 4 클럭이

소요되고 이렇게 되면은

파이프라인이 불리할 수밖에 없죠

그렇죠 그렇기 때문에

시스크는

명령어 파이프라이닝이 불리하다는 아주

치명적인 단점이 있습니다

게다가

시스크가 복잡하고 다양한 명령어들을

활용할 수 있다고는 하지만 대다수의

복잡한 명령어들은 그 사용 빈도가

낮습니다 어차피 사용되는 명령어만

주구장창 쓰이게 돼요 뭐 시스크

명령어 집합 중

20% 정도의 명령어가 전체 사용된

명령어에 대략 한 80% 가량을

차지한다라고 하는 논문도 있습니다

그러니까 시스크가 명령어 집합이

다양하고 복잡한 기능들을 지원하기는

하지만

실제로는 자주 쓰는 명령어만 주고

장창수였다는 거예요 아무리 이렇게

개별적인 명령어가

난 이런 기능도 있어 이런 기능도

제공해 이런 식으로 명령어가 다양한

기능들을 제공해봤자 그런 것들은 사용

빈도가 낮았다는 거죠 아시겠죠

그런 어떤 문제의식 속에서 최근에

각광받고 있는 명령어 집합 구조가

<mark style="background: #FF5582A6;">👉 바로 리스크입니다 리스크. 리두스트 인스트럭션 셋 컴퓨터라고
하는 뜻인데 명령어 집합의 수를 줄였다는
뜻이겠죠 이거는 그렇죠 자 그래서 
이름답게 명령어의 종류가 적고 명령어도 짧고 가급적 1 클럭 내로 실행되는 규격화된 명령어를 사용합니다
</mark>
요컨대 리스크는

단순하고

적은 수의 명령어들을 지원한다 그리고

고정길이의 명령어 집합을 활용한다라고

보시면 됩니다

시스코와의 차이점을 아시겠죠 그쵸

리스크는

시스크에 비해서 비교적 짧고 규격화된

명령어들을 활용하기 때문에

시스크에 비해서 명령어 파이프라이닝에

유리합니다

당연하겠죠 그렇죠 그리고 리스크

구조의 특징이라고 한다면

앞서 시스크 같은 경우에는 뭐 다양한

이런 다양한 주소지정 방식도

지원한다라고 말씀드렸죠

근데 리스크 같은 경우에는 일반적으로

<mark style="background: #FF5582A6;">메모리 접근 방식을 최소화하는 경우가

많습니다

메모리에 접근하는 거를로드 메모리에

저장하는 것을

스토어 이런 식으로 두 개의 명령어로

제한할만큼

메모리 접근을 최소화하는 경향이

있습니다 대신에

레지스터를 10분 활용하는 경향이

있어요

그렇기 때문에

리스크는 시스크에 비해서

범용 레지스터의 종류가 더 많은

경우가 많습니다 왜냐면 리스크 자체가

메모리 접근을 최소화하는 대신

레지스터를 10분 활용하는 방식이기

때문이에요

아시겠죠 다만

리스크는

시스크에 비하면

명령어의 종류 자체가 시스크보다 적기

때문에 더 많은 명령어로서 프로그램을

동작시키게 됩니다</mark> 제가 아까 전에

보여드렸던 예시만 하더라도 이런

소스코드를 컴파일하면

시스크 기반의 x86 64에서는

이만큼의 명령어만 나왔는데

리스크 기반의 암 아미 리스크 기반의

명령어 집합 구조거든요

암으로 암 cpu에서 이거를 컴파일을

하게 되면

시스크보다 훨씬 더 많은 명령어들이

나온다는 걸 알 수가 있죠

이를테면 뭐 예를 들어서

시스크 명령어 한 줄로 수행할 수

있는 기능을

몰리스크는 명령어 종류 자체가 적기

때문에 한 세 줄로 수행할 수 있다

뭐 이렇게 생각하시면 돼요

여기까지 이해 가셨죠 그쵸

명령어의 종류 자체가 적기 때문에

컴파일 했을 때 더 많은 명령어가

나올 수 있다라고 이해하시면

되겠습니다 아시겠죠

자 시스코와 리스크에 대해서 한번

정리해 보겠습니다 자 시스크는

복잡하고 다양한 명령어들을 제공합니다

반면에 리스크는

단순하고

적은 종류의 명령어들을 제공하고요

시스크는 가변 길이 명령어를 사용하기

때문에 하나의 명령어가 실행되기까지

주기가 일정하지 않은 경우가 있습니다

반면에 리스크 같은 경우에는

고정 길이 즉 정형화된 길이의

명령어를 시스크에 비해서 사용하는

경향성이 있습니다 그리고 시스크는

주소지정 방식도 리스크에 비해서 더

다양하고요 그리고

시스크는

명령어 하나하나가 제공해주는 기능들이

워낙 강력하기 때문에

프로그램을 이루는 즉 이렇게 컴파일에

했을 때 나오는

명령어의 수가 적은 경우가 많습니다

리스크에 비하면요 그리고

시스크는

여러 클럭에 거쳐서 명령어가 수행될

수 있고 그런 이유 때문에

리스크에 비하면

파이프라이닝을 하기가 어렵다는 단점이

있다라고 정리하시면 되겠습니다

여기까지 이해하셨죠 아 근데 참고로

말씀드리자면

요즘

시스코와 리스크에 대해서 이렇게

정리를 해 드린 거는 이론적인

이야기고요

현대 cpu의 실제 설계에 대해서 좀

말씀을 드리자면 이제 시스크의 특징은

이게 맞습니다

리스크의 특징도 이게 맞고요 근데

시스크 기반의 명령어 집합을 사용하는

CPU 제조사들 입장에서는 당연하게도

이러한

문제들을 해결해야겠죠

명령어 파이프라이닝 같은 경우에는

현대 cpu에서는 절대로 놓쳐서는 안

돼 너무 중요한 기술이기 때문에

이러한 문제점들을 두고 봐서는

안되겠죠

시스크

기반의 명령어 집합을 사용하는

cpu를 만드는 제조사 입장에서는요

그쵸 자 그렇기 때문에

시스크가

명령어 길이도 들쑥날쑥하고

여러 클럭에 걸쳐서 명령어가 수행되고

라고는 하지만이 시스크가 실제로

실행될 때는

CPU 내부적으로

조금 더 더 작은 단위 명령어보다도

실행되는 단위로써 조금 더 잘게

쪼개서

실행되는 경우가 많습니다 마이크로

명령어라고 가지고

명령어를 실행하는 그 동작 자체도

가급적 1 클럭 내로 잘게 쪼개서

실행하는 경우가 많습니다 그래서

<mark style="background: #FF5582A6;">현대시스크 기반의 프로세서라고

할지라도

실제로 수행되는 거는

CPU 안을 들여다보면이

명령어 하나하나를 실행할 때

내부적으로 잘게 쪼개서 실행을 하기

때문에 내부적으로는

리스크처럼 사용을 한다라고 이해하시면

되겠습니다</mark>

여기까지 이해하셨죠 그쵸

자 이렇게

cpu에 대한 이야기까지 모두 마무리

해봤습니다

잘 들어주셔서 감사하고요

다음 시간부터는 이제 메모리 다른

부품에 대해서 이야기를 해보도록

하겠습니다 아시겠죠 자 그러면 이번

강의는 여기까지 해보도록 하겠습니다

감사합니다