안녕하세요 광주철입니다 자 이번

시간부터이 프로세스에 대해서 어

알아보도록 하겠습니다 지금까지는

단순하게 그냥 실행 중인

프로그램이라고만 표현을 했지만 사실

실행 중인 프로그램은

프로세스라고 한다고 제가 말씀을

드렸죠

<mark style="background: #FF5582A6;">프로그램은

실행되기 전까지는 그냥 보조기억

장치에 있는

데이터 덩어리일 뿐이지만이 보조기억

장치에 저장된 프로그램을

실행해라라고 더블 클릭을 한다든지 뭐

이런 식으로 실행을 해서

메모리에 적재하고 실행하는 순간에 그

프로그램은

프로세스가 됩니다 그리고 이런 과정을

프로세스를 생성한다</mark>라고도 표현하죠

이번 과정에서는 이러한 프로세스들에

대해서 조금 더 자세하게 알아보도록

하겠습니다 일단 프로세스를 직접

눈으로 확인을 해볼까요 일단 윈도우

운영체제를 사용하시는 수강생

분들께서는

작업 관리자를 열어보시면 이런 식으로

프로세스 지금 현재 실행 중인

프로세스들을 확인할 수가 있죠

윈도우뿐만 아니라

macos 라든지

리눅스 운영 사용하시는 분들 또한

프로세스를 확인할 수가 있습니다

PS 명령어라고 하는데요 이런 식으로

간단한 명령어를 통해서

현재 지금 실행되고 있는 프로세스가

어떤 프로세스들이 있는지

직접 확인해 볼 수가 있습니다

상호작용하지 않고 그저 묵묵히

실행되기만 하는 프로세스 그저 정해진

1만을 묵묵히 실행하는 프로세스가

있습니다 자 이렇게 사용자와

상호작용하지 않고 그저 정해진 일만을

묵묵히 수행하는 프로세스를 대몬 혹은

서비스라고도 부릅니다 어 뭐

리눅스라든지 아니면 윈도우 운영체제를

조금

조금

딥하게 보셨던 분들은 아마이 용어들도

한번쯤 접해 보신 적이 있을 거라고

생각을 합니다 왜냐면

윈도우 운영체제 같은 경우에는 아까

전에 말씀드렸죠이 작업관리자를 통해서

현재 실행되는 프로세스를 볼 수

있는데 여기에 서비스라고 하는 탭이

따로 있습니다이 서비스를 눌러 보시면

현재 실행되고 있는 서비스들의 종류를

볼 수가 있어요 아시겠죠

자 이번에는 운영체제가 이러한

프로세스를 어떤 식으로 관리하는지에

대해서 말씀을 드려보도록 하겠습니다

일단 이것에 대해서 먼저 말씀을

드려야 될 것 같아요 일단 <mark style="background: #FF5582A6;">모든

프로세스는

cpu가 필요합니다

실행이 돼야 되잖아요 그렇죠

실행의 주체가 프로세스이기 때문에

모든 프로세스는 실행되기 위해서

cpu가 필요로 합니다 하지만
</mark>
cpu의 자원은 한정되어 있죠 예를

들어서 뭐

프로세스가 100개 1000개 돌고

있다고 해도

cpu가 4개면이 4개의 cpu를

돌아가면서 사용을 해야 되는 거예요

다시 말해서

프로세스들은

돌아가면서 한정된 시간만큼만

cpu를 이용하게 됩니다 이게 어떻게

이루어지냐면

프로세스들은

돌아가면서 한정된 시간만큼만 자기한테

할당된 시간만큼만

cpu를 이용을 하고요 자기한테

할당된 그 한정된 시간만큼 cpu를

이용을 했다면 자기의 차례가 끝났다면

다음 프로세스한테

cpu의 이용권 차례를

양보하게 됩니다

요런 식으로요 줄을서는 거죠 자세한

거는 이제 CPU 스케줄링에서

말씀드리겠지만

CPU 자원 한정되어 있고 cpu를

이용하고자 하는 프로세스들은 이런

식으로 쭉 많기 때문에 일반적으로

많기 때문에 한정된 시간 동안만 한

프로세스는

cpu를 이용하게 되고이

프로세스의 한정된 시간이 끝난다면

얘는 다시 자기의 차례를 기다리게

됩니다 그리고 다음 차례인 프로세스가

cpu를 이용하게 되죠 여기에 타이머

인터럽트라고 하는 용어가 있죠

<mark style="background: #FF5582A6;">타이머 인터럽</mark>트는

야 너 시간 끝났어를 알려주는 특별한

인터럽트입니다

조금 더 정확하게는이 클럭 신호를

발생시키는 장치에 의해서 주기적으로

발생하는 하드웨어 인터럽트의 한

종류라고 보시면 돼요 이거를

타임아웃 인터럽트라고도 부릅니다 다시

말해서 모든 프로세스는 한정된 시간

동안만 cpu를 이용하고

타이머 인터럽트라고 하는

야 너 차례 끝났어를 알려주는 특정

하드웨어 인터럽트가 발 진행을 하면은

프로세스는

다음 프로세스한테

cpu의 차례를 양보하게 됩니다 이런

식으로요 아시겠죠

자 이런 식으로 빠르게 프로세스들은

번갈아가면서 수행되기 마련인데요

이렇게 빠르게 번갈아가면서 수행되는

프로세스들을

<mark style="background: #FF5582A6;">운영체제는 일목요연하게 관리를

해줘야겠죠 이거를 위해서 사용하는

자료구조가

프로세스 제어 블록 이제부터는

pcb라고 부를게요 줄여서

프로세스 제어 블록 pcb라고

부릅니다</mark>이 자료구조라고 하는 말이

컴퓨터 사이언스 공부를 하셨던 분들은

비교적이 단어가 굉장히

익숙하시겠지만이 자료구조라고

하는 용어 자체를 좀 생소하게

받아들이시는 분들도 계실 것 같아요

자료구조는 그냥

다른 거 없습니다 그냥 자료를

저장하는 하나의 형태를 의미한다고

보시면 돼요 지금 여기 예제에서는이

pcb라고 하는 거는 그냥 요런 마치

상품에 달려있는

태그와 같은 정보라고 보시면 됩니다이

프로세스 관련 정보를 저장하는이 태그

같은 정보라고 보시면 돼요 이런

식으로 여러분들 옷 사러 갈 때

옷

새 옷 뒤편에 보면 이런 식으로

태그가 달려 있고 그 옷에 대한

정보들이 이렇게 쭉 적혀 있죠

마찬가지로이

pcb에는이 프로세스와 관련된 온갖

정보들이 이렇게 적혀 있게 됩니다

그리고이 pcb는이 프로세스가

새롭게 생성되면

커널 영역에

커널 영역에이 pcb가 생성이

되고요이 프로세스가 실행이 끝나서

종료가 된다면이 pcb는

폐기됩니다 몇 가지 이해가셨죠 그렇죠

자 pcb는 마치 5세 달려있는

태그처럼이 프로세스와 관련된 온갖

정보들을 저장하고 있는 자료구조라고

말씀드렸죠 자 그러면이 pcb에는

어떤 정보들이 담길까요

참고로 pcb에 담기는 정보는

운영체제마다

차이가 있습니다 근데 대표적인

정보에는

다음과 같은 정보들이 있습니다

앞서 말씀드렸던 것처럼이 pcb는

커널 영역의 생성된다고 말씀드렸죠

그래서 이런 식으로 태그들이

커널 영역에 생성된다라고 보시면

되고요

pcb에 담기는 대표적인 정보에는

요런 것들이 있습니다 이런 것들 밑에

적어 드렸

운영 시즌마다 차이는 있어요 하지만

그럼에도 불구하고 대표적인 정보에는

이런 것들이 있습니다

PCB에 담기는 것
- 프로새스ID
- 프로세스 상태
- 레지스터값
-  CPU. 스케줄링 정보
- 메모리 정보
- 프로세스가 사용했던 파일과 입출력 장치정보 

첫 번째로

프로세스 ID 이거를

pid라고 부릅니다 그리고 레지스터

값 세 번째로

프로세스 상태네 번째로는

CPU 스케줄링 정보 다섯 번째로

메모리 정보

6번째로이 프로세스가 사용했던 파일과

입출력 장치에 대한 정보 이런

것들이이 PCB

태그와 같은 정보에

담긴다라고 보시면 됩니다 그리고

<mark style="background: #FF5582A6;">우형체제는

커널 영역의 적재된 이런 pcb를

보고

프로세스를 일목요연하게 관리한다라고

보시면 되겠습니다</mark>

아시겠죠 자 그러면이 프로세스

아이디부터 한번 볼까요이 프로세스

아이디 다시 말해서 pid는

특정 프로세스한테 붙은 ID 값이라고

보시면 돼요 다시 말해서

특정 프로세스를

식별하기 위해서 부여한

고유한 어떤 번호라고 보시면 돼요

마치

학교에 학번이라든지

회사의 사본 같은 존재라고 보시면

됩니다

학교에 학번이라든지

회사의 사본을 통해서 어떤 특정

학생이라든지 사원을 특정 지을 수

있는 것처럼이 pid를 통해서

특정 프로세스를

특정할 수가 있습니다

그러니까 프로세스를 특정하기 위한

숫자가 바로 pid라고 보시면 돼요

이것 또한 직접 확인할 수가 있어요

예를 들어서

윈도우 운영체제에서

작업 관리자에서 여기서 마우스 오른쪽

클릭한 다음에 요거를 클릭하면은

pid라고 하는 이런 숫자들이

나옵니다 이러한 숫자들이 여기에

있는이 프로세스 각각의 프로세스를

식별하기 위한

고유한 번호라 번호다라고 보시면

됩니다 아시겠죠

그리고 레지스터 값

```ad-question
title: 프로세슺 ㅔ어블록에 왜 레지스터값이 담길까 
```

프로세스 제어 블록 pcb에 왜

레지스톡 값이 담기는지 그 이유를

아는 것이 중요합니다

조금 있다가

컨텍스트 스위치

문맥 교환이라고 하는 개념에 대해서

배울 텐데이 레지스톡 값이 왜

프로세스 제어 블록에 저장되는지 그

이유를 아는게 중요해요 자 레지스터

<mark> 왜 레지스터값이 pcb에 담기느냐 아까

말씀드렸죠 모든 프로세스들은

실행을 위해서

cpu를 필요로 하지만 cpu라고

하는 자원은 한정되어 있다라고 말씀을

드렸습니다

각각의 프로세스는 cpu를 이용하면서

CPU 안에 있는 여러가지

레지스터들을 이용을 하겠죠 예를

들어서 프로그램 카운터라든지 스택

포인터라든지 뭐 여러가지 범용

레지스터라든지

여러가지 레지스터들을 이용하면서이

프로세스들은 실행이 될 겁니다 자

예를 들어서 프로세스 1번이 지금

cpu를 막 쓰고 있다고 한번 가정을

해 볼게요 예를 들어서 CPU 안에

있는

프로그램 카운터라든지

스택 포인터라든지 여러가지 범용

레지스터들을 막 쓰면서 실행이 되고

있었 너무 가정을 해 볼게요 자 근데

타이머 인터럽트가 발생해서 프로세스

1번에 실행이 끝났어요 그럼이

프로세스 1번은

실행을 중단하고 다시 자기의 차례를

기다려야겠죠 자 그럴 때 지금까지

자기가 cpu에서 이용했던 레지스터

값들을 알고 있어야 다시 자기 차례가

왔을 때

실행을

재개할 수가 있겠죠

그렇죠 예를 들어서

프로그램 카운터에는 어떤 값이 당긴다

그랬죠

다음번에 실행할 메모리의 주소가

담긴다 그랬죠 근데 만약에

얘가이 프로세스 1번이

실행이 끝난 다음에 자기 차례 실행이

끝난 다음에 프로그램 카운터 값을

까먹어 버린다면

잊어버린다면

다음번에 실행할 메모리 주소가 어딘지

모르잖아요 다시 자기 차례가 왔을 때

그렇죠 그리고 연산 도중에

타이머 인터럽트가 발생했다고도 한번

가정을 해보죠 그럼 연산에 중간값을

모르면 지금까지 자기 차례가 돌아와도

이전에 내가 어떤 연산을 했는지 그

중간값이 뭔지를 모르잖아요

그렇죠

그렇기 때문에

pcb에는 이러한 레지스터 값을 이제

저장을 해야 됩니다이 프로세스는

자기의 실행 차례가 오면 이전까지

사용했던 레지스터의 중간값들을 모두

복원해서

실행을 재개하기 때문에

pcb에는 보통 이런 식으로 지금까지

사용한 레지스터 값들이

담기게 됩니다 아시겠죠 </mark> 

레지스터 값을 pcb에 명시하는

이유는 이전까지 실행했던 내용을 다시

자기 차례가 오면은 실행을 재개하기

위해서라고도 볼 수 있습니다

아시겠죠

자 다음으로는 프로세스 상태입니다이

프로세스 상태와 관련해서는 다음

강의에서 조금 자세하게 말씀을 드릴

텐데요

프로세스 상태 뭐 생성 상태 대기

상태

준비 상태 실행 상태 이렇게 여러가지

상태가 있어요

근데 지금으로서는 그냥

입출력 장치를 사용하기 위해서 현재

기다리고 있는 상태

현재 cpu를 이용 중인 상태

cpu를 지금 당장이라도 쓸 수

있지만 아직 내 차례가 아니라서

기다리는 상태 이렇게

여러가지 상태라고 하는 것들이 있고

프로세스마다 그 상태 값들이이

pcb에 담긴다라고 보시면 됩니다

아시겠죠

CPU 스케줄링 정보는 뭐냐면 아까

전에 제가 말씀드렸죠이

프로세스마다

cpu를 보통 돌아가면서 사용을

한다고요 자 이때

프로세스가

언제

어떤 순서로 cpu를 할당받아서

사용할지에 대한 정보도이 pcb의

명시가 되는데 보통 그냥 모든

프로세스가 일정한 시간만큼만

돌아가면서

cpu를 쓰지는 않거든요 그 이유에

대해서도

CPU 스케줄링 시간대 자세히

말씀드릴 거예요 어쨌든간에 내가이

프로세스가 나라는 프로세스가

언제

어떤 순서로

cpu를 할당받을지에 대한이 스케줄링

정보도

pcb에 포함된다라고 보시면 됩니다

아시겠죠

이 메모리 정보는 뭐냐면

프로세스가 현재 어느 주소에 저장되어

있는지에 대한 정보를 의미합니다

프로세스마다 당연한 얘기지만 메모리에

저장된 위치가 다릅니다

그렇기 때문에

pcb에는

프로세스가 현재 어느 주소에 저장되어

있는지에 대한 정보도 있어야겠죠 그쵸

앞서 여러분들 주소 지정을 위한

여러가지 레지스터들을 배우셨죠 뭐

예를 들어서 베이스 레지스터라든지 한

개 레지스터라든지 뭐 이런

레지스터들을 배우셨을 텐데 이러한

주소 지정을 위한 레지스터 값들이

메모리 정보로서 저장된다라고 보시면

<mark style="background: #FF5582A6;">되는데 그것보다 중요한 건 뭐냐면이

페이지 테이블에 대한 정보가 담긴다는

겁니다이 페이지 테이블 아직은 이거는

여러분들이 배우지 않아서 그리고

이거는 설명하긴 좀 길어서 그냥

지금으로서는 일단 페이지 테이블에

대한 정보가 담긴다 페이스 테이블은
</mark>
그냥

메모리의 현재 주소를 알 수 있는

정보다

정도로만 그냥 이해하고 넘어가셔도

괜찮습니다

나중에이 페이지 테이블에 대해서

공부를 할 때 제가 다시 한번 언급을

해 드릴게요 아시겠죠 자 마지막으로

pcb에는 사용한 파일과 입출력

장치의 정보들이

명시됩니다 지금 예를 들어서 어떤

프로세스가 어떤 특정 입출력 장치를

사용할 수도 있잖아요 그리고

특정 파일을 열어서 읽는다든지

쓴다든지 이런 작업들을 할 수가

있습니다 자 만약에 그런 과정을

거쳤다면 만약에

프로세스가 실행 과정에서 뭐 어떤

입출력장치나 파일을 사용했다면

pcb에 해당 내용이 명시가 됩니다

다시 말해서

어떤 입출력 장치가이 프로세스한테

할당이 되었는지

어떤 파일들이 열었는지 이런 정보들이

pcb에 기록된다라고 보시면

---- 
## 컨텍스트 스위칭 🎆

되겠습니다 자 다음으로 살펴볼게

바로이 문맥 교환입니다이 문맥 교환이

사실상 오늘 강의에서 가장 중요한

내용이라고 보셔도 무방합니다

문맥 교환은

앞서 제가 말씀드렸던요 내용이 있죠

cpu라고 하는 자원은 한정되어

있지만 프로세스들은 모두 cpu를

원하고 있다

그렇기 때문에

cpu를 돌아가면서 사용하게 된다이

내용이

실질적으로 어떻게 이루어지냐에 대한

내용이라고 보시면 돼요 자 다시

돌아와서 자 문맥 교환 여기에 대해서

이야기를 하려면 일단이 질문부터

```ad-question
title: 프로세스가 a가 실행되다가 프로세스 b로 실해애 순서가 넘어가면 어떤 작업 거쳐야하나
```

시작을 해야 됩니다 한 프로세스 예를

들어서 프로세스 a라고 할게요 한

프로세스가 실행되다가

다른 프로세스 가령 프로세스 b라고

할게요

다른 프로세스로

실행에 순서가 넘어가면

어떤 작업을 거쳐야 될까요

어떤 작업이 이루어질까요

프로세스 a가 막 실행이 되고

있었어요 cpu를 할당받아서 막

실행이 되고 있었어요 자 그러다가

타이머 인터랙트가 딱 발생을 한

거예요 시간 끝 너 촬영 끝났어 이제

프로세스 b한테 차를 넘겨라고 해서

프로세스 b한테

실행 순서가 넘어갔다고 한번 가정을

해 볼게요 자 <mark style="background: #FF5582A6;">그러면

컴퓨터 내부에서는

어떤 과정이 거쳐질까요</mark>

기존의 실행되던 프로세스 a는 일단

지금까지의 중간 정보를

백업해야 됩니다 예를 들어서

앞서 말씀드렸던

<mark style="background: #FF5582A6;">프로그램 카운터를 비롯한 각종

레지스터 값

메모리 정보 열었던 파일 사용한

입출력 장치 등 뭐 이런 중간

정보들을 어딘가에 백업을 해야 됩니다

그리고 이러한 중간 정보를

문맥

컨텍스트라고
</mark>
이야기를 합니다 몇 가지 이해가셨죠

다시 말해서

<mark style="background: #CACFD9A6;">문맥은

다음 차례가 왔을 때

실행을 재개하기 위한 정보가 바로

문맥입니다이 컨텍스트</mark>

실행 문맥을 잘 백업해 두면 뭐 예를

들어서 시간이 다 되거나 cpu를

사용할 수 있는 시간이 다 되거나

예기치 못한 상황이 발생해서

인터럽트가 발생을 하더라도

언제든지 해당 프로세스의 실행을

재개할 수가 있겠죠

지금까지의 중간 정보이 문맥을

어딘가에 백업을 해놨으니까 그 중간

정보를 불러오기만 하면 되니까요

그렇죠 그리고 이렇게 프로세스 a가

중간 정보 다시 말해서 컨텍스트를

백업을 했다면 이제

뒤이어 실행할 프로세스 b의

문맥 다시 말해서 중간 정보를

복구하게 됩니다

그렇게 자연스럽게

프로세스 a를 쭉 실행을 하다가

프로세스 b를 쭉 실행하도록 이렇게

자연스럽게

실행 중인 프로세스가 바뀌게 되는

거예요 자 이러한 과정을

컨텍스트 스위치

문맥 교환이라고

이야기합니다
<mark style="background: #FFF3A3A6;">
몇 가지 이해가셨죠 그쵸 자 이렇게

기존의 실행 중인 프로세스의 문맥을

백업하고

새로운 프로세스 실행을 위해서 문맥을

복구하는 과정을

문맥 교환 컨텍스트 스위칭이라고
</mark>
합니다이 문맥 교환은

여러가지 프로세스가 지금 아까 전에

보여드렸죠 뭐 지금 그 작업 관리자

같은 거 들어가 보시면 수많은

프로세스들이 동시에 실행 중에 있을

텐데 이렇게 수많은 프로세스들이

끊임없이

빠르게 번갈아가면서 실행될 수 있는

원리라고도 볼 수 있어요 자 요거를

그림으로 표현하자면 다음과 같이

표현할 수가 있습니다 예를 들어서

프로세스 a가 쭉 실행이 되고

있었다고 쳐요 자 그러다가 프로세스

a의 시간이 땅끝난 거예요

타이머 인터럽트가 발생을 한 거예요

자 그러면 그 순간에 바로 프로세스

b를 실행하는 것이 아니라

프로세스 a의

문맥을 컨텍스트를

pcb에 저장을 하고

프로세스 b의

pcb로부터 문맥을 복구하는 과정이

있어야 됩니다 이거를 바로 문맥

교환이라고 한다고 말씀드렸죠

그러면 자연스럽게 프로세스 b의

실행을

재개해 나갈 수가 있는 거예요

마찬가지로 프로세스 b의

실행이 끝나면

<mark style="background: #FF5582A6;">타이머 인터럽트가 발생을 하면

프로세스 b의 문맥을

pcb에 저장을 하고 그리고 다음에

실행할 프로세스 뭐 가령 프로세스

a라고 할게요

프로세스 a의 pcb로부터

문맥을

갖고 오고 이거를 문맥 교환이라고

말씀을 드렸죠 이렇게</mark>

문맥 교환을 거치면 자연스럽게

프로세스 a의 실행을 재개할 수

있다라고 보시면 되겠습니다

몇 가지 이해가셨죠 그렇죠

문맥에는 사용했던

레지스터들도 포함된다고 말씀드렸죠

그래서 프로세스 a를 쭉 실행하는

과정에서

여러가지 뭐 프로세스 a 관련된

내용들이 여러 가지 레지스터에 담길

텐데 이런 것들을 프로세스 a의

문맥의

pcb에 저장을 하고 다시 프로세스

피의 문맥을 복구하면은 자연스럽게

실행이

재개가 될 수가 있겠죠 이러한 과정을

문맥 교환이라고 부릅니다

여기까지 이해가셨죠 그쵸 자 지금까지

pcb와 관련된 말씀을 드렸어요

pcb는 사용자 영역이 아니라

커널 영역에 적재되어 있는

옷에 달려있는 태그와 같은

자료구조다라고 말씀드렸죠 특정

프로세스의 달려있는 꼬리표 같은

자료구조다라고 말씀을 드렸어요 자


## 프로세스가 사용자 영역에서 어떻게 저장되는가? 

그렇다면 이번에는이 프로세스가 사용자

영역에는 어떤 식으로 저장이 되는지

한번 알아보도록 하겠습니다 사용자

영역에는

프로세스는

특정 영역을 나누어서 저장이 됩니다

이거를 아마 c언어를 학습해 본 적이

있는 분들은 한 번쯤 보신 적이 있을

텐데요

크게이

프로세스를 차지하고 있는 메모리에

영역이 나누어지는이 4개의 영역을

- 👉코드영역 = 텍스트 영역
- 👉 힙영역 
- 👉 스택영역
- 👉 데이터영역 

코드 영역 이거를 텍스트 영역이라고도

불러요

데이터 영역 10 영역

스텝 영역이라고도 부릅니다

참고로 말씀드리면 이게 전부는

아니에요 대표적으로이 4개의 영역이

있습니다네 뭐 bss 영역 뭐 이런

식으로 다른 영역도 있어요

근데 어쨌든

크게 이렇게 4개의 영역으로서 사용자

영역에

프로세스는 저장이 된다라고 보시면

되겠습니다 아시겠죠 자

요거에 대해서 하나씩 말씀을 드릴게요

### 코드영역 

코드 영역 이거는 텍스트 영역이라고도

부른다라고 말씀을 드렸죠

코드 영역에는이 말 그대로 코드 다시

말해서

<mark style="background: #FF5582A6;">기계어로 이루어진 명령어가 저장되</mark>는

영역을 의미합니다

그러니까 데이터와 명령어로서

프로그램이 이루어져 있고 데이터와

명령으로 프로그램이 실행된다라고 제가

컴퓨터 구조 시간 때 말씀을 드렸죠

코드 영역에는

데이터가 아니라

cpu가 실행할 명령어가 담기는

공간이에요

근데 프로그램을 이루는 명령어가

갑자기 바뀔 일은 없겠죠 그렇기

때문에이

<mark style="background: #FF5582A6;">코드 영역에는이 쓰기가 금지되어</mark>

있습니다

실제로 프로그램이 순차적으로 실행해야

되는 명령어들이 저장되는 공간이기

때문에 일반적으로

공기가 금지되어 있는 영역이에요 이거

다시 말해서

리드 올리 영역이라고도 표현을 합니다

데이터 영역에는 말 그대로 데이터가

담기는데요 모든 데이터가 담기는 것이

아니라

잠깐 썼다가 말 데이터가 아니라

프로그램이 실행되는 내내 유지할

데이터들이 저장되는 영역을 데이터

영역이라고 부릅니다

혹시 이거는 말로 설명하는 것보다는

아마 이제 프로그래밍 언어를 한

번이라도 학습해 보신 적이 있는

분들이 조금 더 와닿을 것 같은데요

저녁 변수라고 혹시 들어보셨어요 저녁

변수 저녁 변수 말 그대로 이거를

영어로 하면 글로벌 베리어블이라고

하거든요 말 그대로 전체 영역에서 쓸

수 있는 변수라고 해서 저녁 변수라고

하는데요 <mark style="background: #FF5582A6;">일반적으로 전역 변수는 한번

썼다가 금세 없애버릴 변수가 아니라

프로그램이 실행되는 내내 유지할

데이터를 저녁 변수로 설정을 합니다

그리고 이런 데이터 영역에는 이러한

전역 변수의 값이 담긴다라고 보시면

되는데요 저</mark>녁

변수라고 하는 용어는 프로그래밍을

배워보신 적이 없는 분들이라도

운영체제를 학습하고자 하셨다면

꼭 기억해 두시는게 좋습니다

왜냐하면이 저녁 변수라고 하는

용어는이 나중에도

프로세스 동기화에 대해서 이야기할

때도 이거는 다시 등장할 용어거든요

그래서

프로그래밍 언어를 한 번쯤 배워보셨던

적이 있는 분들은 뭐 저작변수를

아시겠지만 만약에 저녁 변수라고 하는

용어를 이번에 처음 하셨던 분들은

프로그램이

실행되는 동안 유지되는 변수

프로그램 전체에서

접근할 수 있는 변수로 기억해 주시길

바랍니다 아시겠죠

<mark style="background: #FF5582A6;">참고로 말씀드리자면이 코드 영역

그리고 데이터 영역은

크기가 변하지 않습니다이 크기가

고정되어 있어요 그래서이

고정된 크기와 고정된 영역이라고 하는

점에서 정적할당 영역이라고도 부릅니다</mark>

왜냐면

갑자기 프로그램이 실행되다가 갑자기

프로그램을 이루는 명령어가 갑자기 휙

바뀔 일은 없을 거고

데이터 영역은 말 그대로

프로그램이 실행되는 내내 유지할

데이터니까 바뀔 일이 없겠죠

그렇기 때문에이

코드 영역과 데이터 영역은 하나로

묶어서 정적할당 영역이라고

지칭하기도 합니다

몇 가지 이해가셨죠 그쵸 자

다음으로는

## 힙영역 

힙 영역입니다 힙 영역 또한 이것도

이제 프로그래밍 언어 그 중에서도

c언어를 학습해 본 적이 있는 분들은

더 와닿으실 것 같은데요

이<mark style="background: #FF5582A6;">거는이 사용자가 할당할 수 있는

공간이에요 사용자가 할당할 수 있는

공간은 무슨 말이냐면

프로그램을 만드는 사용자 다시 말해서

프로그래머가

직접 할당할 수 있는 저장 공간입니다

야 나 이만큼의 저장 공간이 필요한데

이만큼의 저장 공간을

직접 할당하고 싶어라고 할 때 사용할

수 있는 영역을</mark> 10 영역이라고

부른다라고 보시면 됩니다 아시겠죠

참고로 말씀드리지만

프로그래밍을 하시는 과정에서

힙 영역에다가 메모리 공간을 할당을

하셨다면 프로그램으로써 이제 메모리

공간을 할당을 했다면

언젠가는 힙 영역에 할당한이 메모리

<mark style="background: #FF5582A6;">공간을 반환해야 됩니다 이거를

요즘은

프로그래밍 언어가 알아서 반환해주는

경우도 있어요 이거를 가비지 컬렉션

가비지 컬렉션이라고 부릅니다
</mark>
그런데 일부 프로 언어 특히 옛날

프로그래밍 언어 예를 들어서 c언어

같은 경우에는 가비지 컬렉션 기능이

없기 때문에 이런 것들을 일일이

메모리를 반환하는 과정을 거쳐야

됩니다

그렇지 않다면 이렇게 할당한 20

영역의 공간은

계속해서 메모리 공간을 차지하면서

메모리에 낭비를 초래합니다 이러한

문제를

<mark style="background: #FF5582A6;">메모리 누수</mark>

메모리 lick라고 합니다 아시겠죠

자 다음은

스택 영역입니다

## 스택 영역

스택 영역은

<mark style="background: #FF5582A6;">데이터를 일시적으로 저장되는 공간을

의미합니다

앞서 데이터 영역은 한 번 쓰고 말

데이터가 아니라 프로그램을 실행하는

내내 유지할 데이터들이 데이터 영역에

담긴다라고 제가 말씀을 드렸죠 반면에

스택 영역은

잠깐 쓰다가 말 값들 그냥 쓰다가 말

것들 이런 것들이 저장되는 공간을</mark>

스택 영역이라고 부른다라고 보시면

돼요 이런 이런

데이터로서 대표적인 예시는 뭐

매개변수 아니면 지역 변수 이런

용어들이 있어요 아마 프로그래밍

언어를

공부하신 적이 있는 분들은 아마이 두

개의 용어도 익숙하실 거라고 믿습니다

만약에이 두 용어가 익숙하지

않으시다면 그냥

일시적으로 사용할 데이터 그냥

프로그램을 사용하는 내내 유지할

데이터는 아니다

정도로만 이해하셔도 좋습니다 아시겠죠

참고로 말씀드리자면 <mark style="background: #FF5582A6;">아까 전에이 두

개의 영역이 정적할당 영역이라고

말씀드렸죠 근데이 두 개의 영역은

프로그램이 실행되는 과정에서

동적으로

동적으로이 크기가 변할 수가 있어요

사용자가 언제

메모리 공간을 할당할지 모르기 때문에

힘 영역 또한

언제든지 가변적으로 변할 수가 있고

스택 영역 또한 일시적으로 저장되는

데이터들이 언제든지 스택 영역에 쌓일

수가 있기 때문에이 스택 영역 또한

영역이 가변적으로 변할</mark> 수가 있습니다

그렇기 때문에

힘 영역과

스택 영역을 이렇게 두 개를 이렇게

퉁쳐서

동적 할당 영역이라고 부르기도 합니다

아시겠죠 일반적으로

힙 영역은

같은 주소에서

높은 주소로 할당이 되고요 일반적으로

스택 영역은

높은 주소에서

낮은 주소로 할당이 됩니다 이거 왜

그러겠어요

앞서 제가 말씀드렸죠

힙 영역과

스택 영역은

실행 과정에서

크기가 가변적으로 변할 수 있다

그렇기 때문에 동적 할당 영역이라고

표현하기도 한다라고 제가 말씀을

드렸죠 근데 만약에

힘 영역과 스택 영역이 이런 식으로

딱 붙어 있다면 이게 언젠가는 메모리

영역이 충돌이 일어날 수가 있겠죠

예를 들어서

10 영역의 힘 영역도 예를 들어서

이쪽 방향으로 커지고

스택 영역도 이쪽 방향으로 커지면

커질 수 있는 공간에 한계가 있잖아요
<mark style="background: #FF5582A6;">
그쵸

그렇기 때문에

스택 영역은

힙 영역과 반대되는 방향으로

차오르게 됩니다 주소가 겹칠 일이

새롭겠죠</mark>

그렇죠 이러한 이유 때문에

스택 영역과 힙 영역은 할당되는이

방향이 반대가 되는 경우가 많다 일단

거의 다 반대로 할당이 됩니다

아시겠죠

자 여기까지 알아두시면 되겠습니다

이번 강의는 여기까지 진행하도록

하겠고요 저는 다음 강의에서

뵙도록 하겠습니다

감사합니다