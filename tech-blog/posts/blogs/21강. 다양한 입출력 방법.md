---
title: 21강. 다양한 입출력 방법
created: 2024-02-27 13:40
last-updated: 2024-03-08 00:45
tags:
  - CS
  - 책-혼공컴운
  - book
tldr:
---

## 👯‍♂️ Intro & tl;dr

Brief introduction about the topic or what the post will cover.

--- 

## 👯‍♂️ 입출력 장치가 어떻게 컴퓨터 내부와 정보 주고받는가?

<mark style="background: #FF5582A6;">입출력 장치가 어떻게

실질적으로 컴퓨터 내부와 정보를

주고받는지 그 방법 세 가</mark>지에 대해서

말씀드려보도록 할 텐데요 저번 시간에

배웠던 장치 컨트롤러에 대한 개념이

나올테니까

혹시라도 저번 영상을 보지 않으신

분들이라면 저번 영상을 보신 다음에이

영상을 보시길 바랍니다 아시겠죠 자

그럼 시작하겠습니다 자 일단은

입출력 방식에는 가장 대표적으로 세

가지가 있습니다

- 👉프로그램 입출력
- 👉인터럽트 기반 입출력
- 👉dma 입출력이 있어요이 세

가지 입출력은 모두 컴퓨터공학 전공

수업에서 아주 주요하게 다루어지는

아주 기본적인 입출력 방식이라고

보시면 됩니다

당연하게도 여러 전공서에서도이를

소개하고 있어요 지금부터 여기에

대해서 하나씩 말씀드려 보도록

하겠습니다 자 일단<mark style="background: #FF5582A6;"> 프로그램

입출력부터 알아보도록 하겠습니다

프로그램이 입출력은 일단 기본적으로

프로그램 속 명령어로서

입출력 장치를 제어하는 방</mark>법입니다

정확하게 말하자면

입출력 장치가 아니라

출력장치의 연결된 장치 컨트롤러를

프로그램 속 명령어로 제어하는

방법이라고 보시면 됩니다

그러니까 <mark style="background: #FF5582A6;">입출력 명령어로서

장치 컨트롤러와 상호작용하는

방법이</mark>다라고 보시면 되겠어요 저번

시간에 이제 장치 컨트롤러에 대해서

학습을 해보셨죠이 장치 컨트롤러가

프로그램이 입출력을 바탕으로 어떻게

동작하는지를 한번 말씀을 드려보도록

할 텐데요 그 예시로

메모리에 저장된 정보를 하드디스크에

백업을 하는 과정에 대해서 한번

생각을 해보도록 합시다

메모리에 저장된 정보를

하드디스크에다가

백업을 한다는 말은

달리 말해서 하드디스크에

새로운 정보 다시 말해서 메모리에

저장된 정보를

쓰기를 하는 작업이라고도 볼 수

있겠죠

그렇죠 자 이것들을 장치 컨트롤러와

어떤 식으로 상호작용하는지 프로그램이

입출력을 통해서 어떻게 상호작용하는지

말씀드려보도록 할게요

<mark style="background: #FF5582A6;">자 메모리에 저장된 정보를

하드디스크에 백업한다는 말은 방금

말씀드렸다시피 새로운 정보를 쓰는

과정이기 때문에

cpu는

장치 컨트롤러의 제어 레지스터에다가

쓰기 명령을 내보내게 됩니다 제어  
</mark>  
레지스터는 입출력장치가 해야 되는

동작 수행할 동작을 여기 안에다가

저장을 하게 된다고 말씀드렸죠 그렇죠

제어 정보를 저장하는 레지스터가 제어

레지스터라고 말씀을 드렸잖아요 그렇죠

그렇기 때문에

첫 번째로

cpu는 하드디스크 컨트롤러에 제어 레지스터에다가 쓰기 명령을 이렇게 내보내게 됩니다  
자 그러면 하드디스크 컨트롤러는 제어 레지스터를 보고 하드디스크의 상태를 확인합니다 어 새롭게 뭔가를 써야 되는 작업이 있네 하드디스크에다가 지금 써도 되는지이 쓰기 작업을 할 수 있는지 한번 상태를 확인해 봐야겠다 이러면서 이제 하드디스크의 상태를 확인하게 됩니다 그리고 상태 레지스터에다가 준비 완료 만약에 이제 하드디스크가 새롭게 이제 쓰기 작업을 할 수 있는 상태라면 준비가 완료된 상태라면 하드디스크 컨트롤러는 상태 레지스터의 준비 완료라고 이제 표시를 하게 됩니다 어 그리고 이제 준비가 완료됐으면 cpu가 확인을 하고요 이게 첫 번째에요 cpu는 상태레지스터를 주기적으로 읽어보면서 주기적으로 읽어 보면서 하드디스크의 준비 여부를 확인하고 만약에 cpu가 하드디스크가 준비가 됐구나라고 판단이 되면 백업할 메모리 정보 그러니까 쓰기 작업을 할 그 정보를 데이터 레지스터에다가 쓰게 됩니다이 과정을 계속 백업 작업이 끝날 때까지 반복하시면 돼요 그러니까 아직 백업 작업이 끝나지 않았다면 1번 여기서부터

계속 반복을 이렇게

계속 이렇게 반복을 하게 되고

쓰기가 끝났다면

작업이 종료되게 됩니다 자 이런

식으로 하드디스크 컨트롤러에

특정 레지스터에다가 이제

입출력 명령으로서

입출력 작업을 수행하는 것이 바로

프로그램이 입출력이다라고 보시면

되겠어요 아시겠죠 자 이런 식으로

cpu가 장치 컨트롤러의 레지스터 값을 읽고 씀으로써 이루어지는 입출력 방식이 바로 프로그램이 출력 방식이다라고 보시면 



```ad-question
title: 입출력 장치 종류가 많은데(프린터, 마우스, 키보드등, 같은 모니터마다 회사도 다른데)이 이 입출력 장치 정보 어떻게 규격화 하고 CPU가 그런 장치 컨트롤러의 레지스터를 다 알 수 있을까?

그러니까 cpu가 이런 식으로 장치 컨트롤러의 레지스터와 상호작용함으로써 입출력 작업이 이루어지잖아요 그렇죠 근데 cpu는 이러한 레지스터들의 종류이 장치 컨트롤러도 여러 개가 있을 거 아니에요 이러한 장치 컨트롤러의 레지스터의 레지스터이 출력 장치의 주소라고 표현을 할게요 이런 레지스터들을 어떻게 인식을 하고 또 알 수가 있을까요 그러니까 이런 명령어들 있죠 이런 명령어들은 어떤 식으로 명령어로 표현되고 또 어떻게 메모리에 저장이 될까요 입출력장치의 주소를 어떻게 알 수가 있을까요 cpu는 프린터 컨트롤러의 상체 레지스터를 읽어라 그러면이 명령어를 실행하면 프린터기의 상태를 알 수가 있겠죠 cpu는 프린터 컨트롤러의 데이터 레지스터에다가 100을 써라이 명령어를 실행하면 프린터기에다가 100을 이제 전송을 할 수가 있겠죠 키보드 레지스터의 상태를 읽어라라고 하면 키보드에 연결된 키보드의 상태를 받아 볼 수가 있겠죠 근데 프린터 컨트롤러의 상태 리스터 데이터 레지스터 하드디스크 컨트롤러의 데이터 레지스터를 cpu가 어떻게 인식하고 알 수가 있을까요
```
자 여기에는 크게 두 가지 방식이 있습니다. (굉장히 중요한 개념!)  
요컨대    프로그램이 입출력 방식은    cpu가 장치 컨트롤러의 레지스톡    값을 읽고 씀으로써 이루어지는데   cpu가 장치 컨트롤러의 레지스터    값을 알기 위한    방법으로써이 두 가지 방식이 있다는    거예요..


- 👉메모리 맵 입출력 그리고
- 👉고립형 입출력(=Isolated IO)


```ad-important
title: 메모리맵 입출력
메모리 맵 입출력부터 말씀을    드려보도록 할게요    메모리 맵 입출력은    메모리에 접근하기 위한 주소공간과    입출력장치에 접근하기 위한 주소    공간을 하나의 주소 공간으로 간주하는    방법입니다.
```

주소공간 = 그냥 주소들이    모여 있는 주소들이 있어서 주소에    접근할 수 있는 공간

![Uploading file...0vzw2]()

예를 들어서    어떤 컴퓨터가 있는데이 컴퓨터는 예를    들어서 1024개의 주소를 표현할 수    있는 컴퓨터다라고 가정을 해 볼게요    여기서    메모리 맵 입출력 방식을 사용하면은    1024개의 주소를 전부 다 메모리를    위해서 사용하지 않습니다  .  
1024개의 주소 공간을 전부 다    메모리를    접근하기 위해서    메모리의 주소를 표현하기 위해서    사용하지 않아요.  
그림은 이런 식으로    나누어서 이제 주소를 공간을 관리하는고있다.
- 0~511번지 = 메모리 위한 주소공간
- 512~끝 : 입출력 장치 위한 주소공간  
 그러니까    메모리에 출력은    메모리에 접근하기 위한 주소공간과    입출력 장치에 접근하기 위한 주소    공간을 하나처럼    간주하는 방식이에요    자 이거를 아마 말만 들었을 때는    조금 모호하실 수가 있는데  
예시)  
```ad-question
title: 프린트 컨트롤러의 데이터 레지스터, 키보드 컨트롤러의 상태 레지스터, 하드디스크 컨트롤러의 데이터 레지스터등 이런 레지스터들을 CPU는 어떻게 인식하나? -> 메모리맵에서는 ...
- 516번지: 프린트 컨트롤러의 데이터 레지스터
- 517번지: 프린트 컨트롤러의 상태 레지스터
- 518번지: HDD 컨트롤러의 데이터 레지스터
  519번지: HDD 컨트롤러의 상태 레지스터
```

- '517번지 읽어 들여라 ' == 프린터 상태 읽기
- 518번지에 a를 써라 == 하드디스트케 a써라



자 이럴 경우에는    프린터한테 제가 프린터에 상태를 읽어    드리기 위해서는 그냥 517번지를    읽어라 나는 명령으로서 이제 프린터의    상태를 읽을 수가 있겠죠    마찬가지로    하드디스크 컨트롤러의 데이터    레지스터에다가 특정 값을 쓰기    위해서는    이렇게 하드디스크 컨트롤러의 데이터    레지스터에다가 어떤 값을 쓰기    위해서는 그냥 518번지에다가 a를    써라 이런 명령어로 이제 실행을 할    수가 있겠죠 자 그러면 하드디스크    컨트롤러의 데이터 레지스터의 a를    쓰게 되는 것과 똑같아지겠죠    

- 메모리 접근 명령어 == 입출력 장치 접근 명령어

그렇죠 근데 지금이 명령어들 보면    메모리에 접근하는 명령어랑 똑같이    생겼죠    메모리를 읽어라    메모리에 어떤 값을 써라 이것과    똑같이 생겼죠 다시 말해서    메모리에 접근하는 명령어와 입출력    장치에 접근하는 명령어가 똑같이    생겼습니다    이거 왜 그러냐면    메모리에 접근하기 위한 주소공간과    입출력장치에 접근하기 위한 주소    공간을 하나의 주소공간으로서 마치    그<mark style="background: #FF5582A6;">냥    동일한 주소 공간처럼    간주를 했기 때문이에요 그게 메모리    맵출력 방식입니다    아시겠죠 그렇기 때문에    굳이 별도의 입출력 명령어가 필요하지    않은 방식이에요 메모리를 읽고 쓰는    것과 동일하게    장치 컨트롤러의 레지스터에 이제 값을    읽고 쓸 수가 있게 되는 거예요    그렇기 때문에    메모리에 접근하는 명령어와    입출력 장치에 접근하는 명령어가    동일한    입출력 방식이 바로 메모리 맵출력    방식이다라</mark>고 보시면 되겠습니다    




```ad-important
title: 고립형 입출력
고립형 입출력은 메모리맵 입출력과 반대입니다    메모리를 위한 주소공간과    입출력 장치를 위한 주소 공간을    분리해서 생각하는 방식이    고립형 입출력 방식이라고 보시면 돼요
```


![Uploading file...03iln]()

	
자 예를 들어서    1024개의 주소공간을 표현할 수    있는 컴퓨터가 있다고 가정을 해봅시다    앞선 예시에서는 그 1024개의    주소공간에서 일부를 메모리를 위해    사용하고 일부를 입출력장치를 위해서    사용을 했죠    근데    고립형 입출력에서는 여기    2024개를    메모리를 위해서도 사용할 수 있고    입출력 장치를 위해서도 사용할 수가    있습니다    🤔🤔🤔🤔🤔🤔🤔 이게 우찌가능?? 

![](https://i.imgur.com/Sv5nsRb.png)


그게 어떻게 가능하냐면  <mark style="background: #FF5582A6;">  입출력 전용 명령어를 통해서 사용할    수가 있어요    여기에 자세히 보시면 제어버스에서    메모리 읽기 쓰기 버스뿐만 아니라    입출력장치 읽기 쓰기선이 또 별도로    있거든요 만약에 cpu가 메모리 읽기    쓰기 선이 활성화되는이 선이    활성화되는 명령어를 실행할 때는    메모리에 접근하도록 하면 되고 만약에    입출력장치 읽기 쓰기 선이 활성화되는    명령어 그러니까 입출력 전용 명령어를    실행할 때는    입출력 장치에    접근을 할 수가 있겠죠    자 이런 방식을 통해서    1024개의 주소 공간을 입 메모리를    위해서도 활당할 수가 있고이    출력장치를 위해서 할당할 수가 있는    거예요 다만    입출력 전용 명령어를 사용을 해야    됩니다 이게 바로    고립형 입출력이라고 보시면 되겠습니</mark>다







아시겠죠    정리하자면 메모리에 입출력은    메모리에 접근하는 명령어와 입출력    장치에 접근하는 명료와 같았습니다    왜냐하면 주소 공간에 그냥 하나로    간주했기 때문이에요 하나로 여기에    접근하는 명령어랑 여기에 접근하는    명령어가 다를 필요가 없었던 거죠    근데    고립형 입출력은 아예 그냥 별도의    주소 공간으로 간주를 하기 때문에    여기에 접근하기 위해서는    메모리 읽기 쓰기 선을 활성화시키는    명령어를 실행을 해야 되고 아이고    여기에 접근하기 위해서는    입출력 장치 읽기 쓰기 선을    활성화시키는 입출력 전용 명령어를    사용함으로써 여기에 접근할 수가 있게    되는 거예요 





몇 가지 이해하셨죠 그쵸 자 정리를    해보자면<mark style="background: #FF5582A6;"> 프로그램이 입출력 방식에는    크게 메모리 맵 입출력과 고립형    입출력이 두 가지 방식이</mark> 있는데요    <mark style="background: #FF5582A6;">메모리 맵 </mark>입출력은    메모리와 입출력 장치는 같은 주소    공간을 사용하지만    고<mark style="background: #FF5582A6;">립형 입출력 방식</mark>에서는    메모리와 입출력 장치는 분리된 주소    공간을 사용하게 됩니다    그렇기 때문에    

- 메모리 맵 입출력에서는 당연하게도    메모리의 주소 공간이 축소되는 단점이    있었어요    그렇죠 1024개 주소 공간을 활용할    수 있는데도 불구하고    메모리에 접근할 수 있는 주소 공간은    제한됐잖아요    그렇죠 하지만    굳이 별도의    입출력 전용 명령어는 필요하지가    않았습니다    메모리와 입출력 장치에 같은    명령으로서 접근할 수가 있었어요    
- 고립형 입출력은 반대죠    메모리 주소 공간이 축소되진 않지만    입출력 전용 명령어를 사용을 해야    된다라고 보시면 되겠습니다    입출력 전용 명령어라고 한다면 뭐    x86cpu 같은 경우에는    in out 뭐 이런 명령어들이    있어요 아시겠죠 어쨌든이 두 가지가    프로그램 입출력에 두 가지    방식이다라고 보시면 되겠습니다   


### 👯‍♂️ 인터럽트

아시겠죠    자 다음으로는 인터럽트 기반 입출력    방식에 대해서 말씀을 드려보도록 할    텐데요 여러분들 인터럽트에 대해서    제가 이거 수업으로 다루었던 거 혹시    기억하시나요    CPU 시간 때 다뤘었는데이 하드웨어    인터럽트 인터럽트에 다른 개념에    대해서도 말씀을 드렸고    입출력장치에 의해서 발생하는 하드웨어    인터럽트가 무엇인지에 대해서도 말씀을    드렸습니다    CPU 사이클의 낭비를 막기 위해서    입출력 장치가 일을 할 동안 다른    일을 할 수 있게 하기 위해서 일종의    알람 같은 개념이라고 말씀을 드렸죠    그렇죠 그리고 cpu의 플래그    레지스터라고 하는 특별한 레지스터가    있었어요

 플래그 레지스터    속에 인터럽트 비트가 있었습니다  
 이    인터럽트 비트가 활성화가 되면    인터럽트를 받아들일 수 있게 되고    비활성화 하게 되면 인터럽트를 받지    않게 된다    라고 말씀을 드렸죠.
 
  정확하게는    하드웨어 인터럽트를 받을 수 있게    되고 받을 수 없게 된다라고 말씀을    드렸습니다 그리고 인터럽트 요청    신호는 저 지금 끼어들어도 되나요라고    이제 cpu한테    입출력장치가 요청을    신호로서 보내주는 거라고 말씀드렸고    인터럽트 서비스 루틴은    인터럽트를 처리하기 위한 특별한    프로그램이다라고 말씀을 드렸습니다    아시겠죠 이렇게 간략하게 복습을 하고    이제 인터럽트 기반 입출력에 대해서    말씀을 드릴게요    
  
  
  자 인터럽트 그 중에서도 하드웨어    인터럽트는 앞선 시간까지만 하더라도    입출력장치에 의해서 발생합니다라고    제가 말씀을 드렸는데 이제 여러분들은    장치 컨트롤러에 대해서 학습을    하셨잖아요    그렇기 때문에이 인터럽트에 대해서    조금 더 자세하게 학습을 할 수가    있습니다 하드웨어    인터럽트는    입출력 장치에 의해서 발생하는게    아니라 조금 더 정확하게 말씀드리자면    장치 컨트롤러에 의해서 발생을 합니다    그러니까    cpu가 입출력 명령어가 있다고    가정을 했을 때 입출력으로 뭔가    명령을 할게 있다고 가정을 했을 때    장치 컨트롤러에 입출력 명령을 하게    되고 만약에 다 됐다면    장치 컨트롤러가    cpu한테    인터럽트 요청 신호를 이렇게 보내는    방식으로    인터업트가 진행이 됩니다 이런    방식으로 입출력 작업을 하게 되면    당연하게도 cpu는 조금 더 싸이클을    CPU 사이클을    효율적으로 관리할 수가 있겠죠 시간을    알듯 살들이 쓰면서 이제 입출력    작업을 할 수가 있겠죠 왜냐하면 제가    앞서 프로그램 입출력 방식에 대해서    말씀을 드렸을 때 이렇게 말씀을    드렸죠 상태 레지스터를 주기적으로    읽어 보면서 이제 하드디스크의 준비    여부를 확인한다라고 말씀을 드렸잖아요    그러니까 하드디스크에    백업할게 있다면    야 너 준비됐니 아니네    준비됐니 아니네    준비됐니 아니네 준비됐니 어 준비됐네    자 이제 시작하자 자 이런 식으로    주기적으로 읽어 볼 수밖에 없었지만    인터럽트를 이용하면은 이런 식으로    그냥 요청 신호를 받으면 그때 가서    그냥 봐주면 되기 때문에    조금 더    cpu는 효율적으로 일을 할 수가    있다라고 보시면 되겠습니다
```ad-question
title:  인터럽트와 폴링의 차이는 뭔가?
```
  
   이거를    이제 인터럽트와 반대되는 이러한    개념을 폴링이라고도 해요 아시겠죠 자    그렇다면 이번에는    입출력장치에 의해서 발생하는이    하드웨어 인터럽트를 조금 더 자세하게    조금 더 일반적인 관점에서 알아보도록    하겠습니다 아시겠죠 여러분들이    컴퓨터를 사용하실 때는 보통 입출력    장치를 동시다발적으로 많이 사용하시기    때문에    당연하게도 입출력 요청 신호는    cpu한테 동시다발적으로 한 번에    많이 오게 됩니다    입출력 장치를 많이 사용하게 된다면요    예를 들어서 지금 저만 하더라도    지금 저는 여러분들한테이 강의를    보여드리기 위해서 마이크에 대고    이야기를 하고 있고 모니터는 지금    ppt 자료를 띄워놓고 있고 이렇게    마우스로 움직이고 있고 막 그러거든요    자 이런 것들이 제가 동시다발적으로    여러 입출력장치들을 이용하고    있다라고도 볼 수 있거든요 자 만약에    이러한 입출력 장치들이 제 컴퓨터의    cpu에다가 인터럽트 요청 신호를    보낸다면 당연하게도 제 cpu는    인터럽트 요청 신호를 동시다발적으로    많이 받게 되겠죠    그렇죠 자 그렇다면 이런 식으로    입출력장치들의 장치 컨트롤러로부터    동시다발적으로 많은 인터럽트 요청    신호들이 cpu로 오게 된다면    cpu는 이렇게 많은 인터럽트 요청    신호들을 어떻게 처리를 해야 될까요 
   
그냥    간단하게 생각했을 때는 그냥    인터럽트가 발생한 순서대로 처리하면    됩니다라고도 생각할 수가 있거든요    실제로 가능합니다    cpu가 만약에 플래그 레지스터 속에    인터럽트 비트를 만약에 비활성화하고    인터럽트를 처리하는 경우에는    다른 인터럽트를 받아들이지 않겠다라는    것과 같기 때문에 뭐 이런 식으로도    순차적으로도 처리하게끔 할 수가    있습니다 예를 들어서    cpu가 이렇게 프로그램을 쭉 실행을    하다가 인트로트 a와 b가 동시에    발생을 했는데 a가 조금 더 빨리    왔어요 그럴 경우에는 이렇게 cpu는    프로그램을 쭉 실행을 하다가 인터럽트    서비스 루틴 a를    쭉 실행을 하고 되돌아와서 다시    인트로트 서비스 루틴 b를 실행하고    되더라 오고 나중에 되돌아온 뒤에    처리하던 프로그램을 마저 처리하고    이런 식으로 처리가 되게끔 할 수가    있겠죠    이게 이제 순차적으로 인터럽트를    처리하는 방식인데요    참고로 말씀드리자면 이런 식으로    플래그 레지스터 속 인터럽트 비트를    비활성화한 채 인터럽트를 순차적으로    처리하는 이런 방식은 하드웨어    인터럽트 그러니까 입출력장치에 의해서    발생한 하드웨어 인터럽트는 이런    식으로 처리가 할 수 있는데    인트럭트 비트를 비활성화 해도    순차적으로 처리가 불가능한 인터럽트가    있습니다 그거를 넌 마스커브 인터럽트    nmi라고도 부르거든요 예를 들어서    하드웨어가 고장 났다던지 정전이    발생했다던지 이런 식으로    빨리 처리해야 되는    정말 정말 중요도가 높은    크리티컬한 인터럽트가 발생했을    경우에는    인터럽트 비트를 비활성화 해도 그    인터럽트는 처리할 수밖에 없습니다    이런 것들은이 출력장치에 의해서    발생하는 하드웨어 인터럽트의 한정에서    말씀을 드리는 거예요 아시겠죠 자    어쨌든    동시다발적으로 인터럽트가 발생하면    요런 식으로 인터럽트가 발생한 순    그대로 단순히 이렇게 순서대로    처리를 할 수가 있다라고 보시면    되겠습니다

```ad-question
title: 인터럽트에 우선순위가 있다면 어떻게 처리하나?
```

이 첫 번째 방식인데요    근데 이런 방식은    현실적이진 않아요 왜냐하면 모든    인터럽트를 전부 다 순차적으로 처리할    수는 없습니다    인터럽트 중에서도 하드웨어 인터럽트    중에서도 더 빨리 처리해야 되는    인터럽트가 있기 마련이거든요 여기서    더 빨리 처리해야 되는 인터럽트를    조금만 더 달리 말아라 하자면    우<mark style="background: #FF5582A6;">선순위가 높은 인터럽트가 있습니다    더 우선순위가 높고 더 빨리 처리해야    되는 인터럽트가 있어요 자   </mark> 우선순위를 반영한 인터럽트는 이런    식으로 처리를 할 수가 있습니다 뭐    예를 들어서    인터럽트 a의 우선순위가 b보다 높은    경우에는 당연히 a를 먼저 실행을    해야 되기 때문에    동시다발적으로 a와 b가 인터럽트    요청 신호를 보냈다라고 할지라도    a가 이런 식으로 먼저 실행이 됩니다    이렇게    이 순서대로 실행이 돼요 하지만    a의 우선순위가 b보다 낮은 경우에는    B 요청 신호가 왔으면    b를 무조건 우선순위가 높기 때문에    b를 실행을 해야 돼요    인터럽트 서비스 루틴 a를 실행하는    도중이어도 b를 실행을 해야 됩니다    그렇기 때문에 처리되는 순서는 이렇게    돼요    프로그램이 이렇게 쭉 실행이 되다가    인터럽트 a가 발생을 해서    인터럽트 서비스 루틴 a를    쭉 실행을 하는데 이때 만약에    인터럽트 b가 발생을 했어요 근데    b가    a보다 우선순위가 더 높아요 그럴    경우에는    a를 중단하고    b로 점프해서    b를 아주 실행한 다음에 a를 마저    처리해서 다시 되돌아오게 됩니다 이런    식으로 자 이게    인터럽트 a의 우선순위가 b보다 낮을    경우에 이런 식으로 처리가 돼요 이게    우선순위를 반영한 인터럽트 처리    방식이라고 보시면 됩니다 자 이런    경우에는    앞서 설명해 드렸던 것처럼    인터럽트 비트를 비활성화 해도 반드시    먼저 처리해야 되는 정말 급한    인터럽트 막을 수 없는 인터럽트    넌 마스커    줄여서    nmi가 발생한 경우    혹은 플래그 레지스터 속 인터럽트    비트를 활성화한 채 이제 인터럽트를    처리하는 경우에는 이런 식으로    우선순위를 반영한 인터럽트 처리를    하게 돼요 자 이렇게 우선순위를    반영해서 다중 인터럽트를 처리하는    방식에는 다양한 방식들이 있지만 가장    <mark style="background: #FF5582A6;">대중적으로 사용되는 방식은 이러한    pic라고 하는    작은 하드웨어를 사용하는 방식이    있습니다이 PIC 프로그래머블    인터럽트 컨트롤러는 어떤 하드웨어냐면    여러 장치 컨트롤러에 연결이 되고요    여기 지금 핀이 보이시죠 이렇게    다리가 많잖아요 여기에    각각    장치 컨트롤러들이 연결이 되어    있다라고 보시면 돼요 이렇게 이렇게    여러 장치 컨트롤러에 연결이 돼서    장치 컨트롤러의 하드웨어 인트롭트들을    우선순위를 판단을 한 다음에    cpu한테 그 많은 인터럽트 중에서    너는 지금 이거 먼저 실행해야 돼라고    우선순위를 판단해주는 하드웨어가    바로이 pic라고 보시면 </mark>됩니다    참고로 얘는 nmi의 우선순위까지    판단하지는 않아요 하드웨어 인터럽트의    우선순위만 판단합니다    nmi는 그냥 별도의 핀이 있습니다    cpu가    nmi가 정말 급하게 뭐 예를 들어    하드웨어가 고장났다 이러면 뭐 이런    거 판단할 이런 자시고 할 것도 없이    바로 처리도 해야 되기 때문에 이런    nmi의 우선순위까지 판단하지는    않아요    nmi가 발생하면 그냥 cpu에    다이렉트로    처리가 되도록 하는 경우가 많습니다    아시겠죠    얘는 이제    장치 컨트롤러와    CPU 사이에 이런 식으로 연결이    돼서 여기 장치 컨트롤러들이 이렇게    핀들에 다 연결이 된 거예요 그리고    장치 컨트롤러는 인터럽트 요청 신호를    보낸다고 말씀드렸죠 그래서 인터럽트    요청 신호를 이렇게 많이 이렇게    동시다발적으로 pic한테 보내게    되면은    prc는    장치 컨트롤러와    CPU 사이에서    어떤 인터럽트를 가장 먼저 처리를    해야 되는지를    판단해서이 많은 인터럽트 중에서    cpu가 처리해야 되는 인터럽트를    알려주게 됩니다 이런 식으로    자 이런 하드웨어가 바로 pic고이    pis를 이용해서    우선순위를 반영한 다중인    처리가 가능하다라고 보시면 되겠습니다    참고로이 피아이스는 하나만 사용하진    않고 여러 개를 사용하는 경우가    많아요 그리고    윈도우 운영체제라든지 이런 식으로    이제 제어판이었나    특정 메뉴에 들어가 보시면 이런    식으로 동시에 다발적으로 발생하는    여러 하드웨어 인터럽트의 우선순위를    직접적으로 확인해 볼 수도 있습니다    자 여기까지가 인터럽트 기반 입출력    방식에 대해서 설명드린 내용이었어요    

---- 

자 지금까지 입출력 방식에 대해서는    두 가지를 설명드렸습니다 하나는    프로그램 입출력 방식이었고 또 하나는    인터럽트 기반 입출력 방식이었어요이  <mark style="background: #FF5582A6;">  두 가지 입출력 방식의 공통점이    있다면 그거는    입출력장치와 메모리 간의 데이터    이동은 반드시 cpu가 주도를 해야    되고요    그리고 입출력 장치와 메모리 간의    데이터가 이동을 할지라도 이동되는    데이터는 반드시 cpu를 거친다는    공통점이 있습니다   </mark> 당연한 얘기 아니야라고 생각하시는    분들도 계실 거고 이게 무슨 소리지    너무 당연해서 이게 무슨 소리지    하시는 분들도 계실텐데 예시를 통해서    말씀을 드리자면 예를 들어서    입출력 장치 뭐 이를테면 하드디스크에    있는 데이터를    메모리에다가 저장한다라고 한번 가정을    해 볼게요이 경우에는 하드 디스크의    데이터 레지스터에 저장되어 있는 값을    입출력 장치를 읽어들임으로써 레지스터    cpu의 레지스터로 읽어드리게 되고    cpul 레지스터를 메모리 쓰기    명령어를 통해서 이렇게 쓰게 됩니다    <mark style="background: #FF5582A6;">그러니까    이동되는 데이터가 반드시 cpu를    거친다는 거예요 이런 식으로    처음에 cpu가    장치 컨트롤러 하드디스크라고 치면    하드디스크에 데이터 레지스터로부터    메모리에 쓰고자 하는 값을    cpu의 레지스터로    읽어드리게 되고 이렇게 레지스터로    읽어들인 값을 다시 메모리로    쓰게 됩니다 반대의 경</mark>

![Uploading file...18zri]()

우도    마찬가지예요 예를 들어서 메모리에    저장된 값을 하드디스크에다가    저장하겠다라고 하는    어떤 작업이 있다고 가정을 했을 때이    경우에도 하드디스크    장치 컨트롤러에 내보내고자 하는    데이터를    메모리로부터    cpu는 읽어들이게 되고 cpu의    레지스터로 읽어드리게 되고 이렇게    읽어드린 값을 다시    장치    컨트롤러의 레지스터로    쓰게 됩니다 자 이런 식으로    입출력 장치와 메모리 간의 데이터    이동은 반드시 cpu가 주도를 해야    되고 이동되는 데이터도 반드시    cpu를 거친다라고 하는 점을 알    수가 있죠

### 👯‍♂️ DMA 입출력

그렇죠    근데    cpu는 가뜩이나 바빠 죽겠는데    입출력 장치와 메모리 사이에서    전송되는 모든 데이터가 반드시 다    cpu를 거쳐야 된다면 가뜩이나 바쁜    cpu는 입출력장치를 위한 연산    때문에 시간을 뺏길 수밖에 없겠죠    가령 하드디스크 백업 같이 뭐    대용량의 데이터를 이동해야 되는    입출력 작업이 있다라고 가정을 한다면    뭐 이럴 경우에는 당연히 cpu에    부담이 더 커질 수밖에 없겠죠    그렇죠 자 이러한 문제를 이제    해결하기 위해서 등장한 기능이 바로  <mark style="background: #FF5582A6;">  dma 다이렉트    메모리 액세스라고 하는 기능입니다    이거는    이름 그대로    메모리랑 장치 컨트롤러가 주고받을    데이터가 있을 적에    cpu를 거치지 않고    입출력장치가 메모리에 직접적으로    접근하는 기능이라고 보시면 됩니다    직접적으로 접근하는 기능 현대 입출력    장치에 있어서 너무너무 중요하게    다루어지는 기능 중에 하나에요    dma는    cpu를 거치지 않고    메모리와 입출력 장치간에 데이터를    주고받는 입출력 방식입니다라고 써    있죠 말씀드리자면 dna를 하기    위해서는 dma 입출력을 하기    위해서는    dma    컨트롤러라고 하는 역할을 하는    하드웨어가 필요한데 이제 dma    컨트롤러를 통해서    dna를 할 수 있다라고 보시면    되겠습니다 아직까지</mark>는    조금 모호하실 수도 있다라고 생각이    드는데요이 dma 입출력의 과정을    조금 더 자세하게 설명을 드리자면    cpu는    첫 번째로 만약에 어떤 입출력 작업을    해야 된다면이 dma 컨트롤러한테    입출력 작업을 명령을 하게 됩니다    첫 번째로 그리고 dma 컨트롤러는    CPU 대신에    장치 컨트롤러와 상호작용하면서 입출력    작업을 수행하게 됩니다    CPU 지금 얘가 cpu가 dma    컨트롤러한테 입출력 작업을 명령하면은    <mark style="background: #FF5582A6;">GMA 컨트롤러가    cpu에 입출력 작업을 일종의 대행</mark>    역할을 한다고 보시면 돼요 이런    식으로    장치 컨트롤러와 상호작용하면서    얘는 장치 컨트롤러랑 상호작용을    하면서    입출력 작업을 수행하게 되는데 이때    dma 컨트롤러는    필요할 경우에    메모리에 직접적으로 접근해서 메모리에    직접적으로 접근해서    읽고 쓸 수가 있게 됩니다    몇 가지 이해가셨죠 그쵸 자 

그리고    입출력 작업이 끝나면 dma    컨트롤러는 인터럽트를 통해서    cpu의 작업이 끝났음을 이렇게    알려주게 됩니다 자 그러면    메모리랑 장치 컨트롤러 사이에서    주고받는 데이터는    cpu를 거치지 않게 되겠죠    그렇죠 그리고 cpu는 그동안에 다른    일도 할 수가 있겠죠    그렇죠 자 이게 바로 DNA    입출력이다라고 보시면 되겠습니다    그림으로도 표현이 되어 있네요    cpu는    첫 번째로    dma 컨트롤러에 입출력 작업을    명령을 하게 되고요    어떤 장치에    어떤 연산을 수행을 해야 돼 그리고이    연산을 수행할 때 메모리에 어떤    번지에다가도 어떤 연산을 수행해야 돼    이러한 정보를 담은 입출력 작업을    dma 컨트롤러한테    명령을 하게 됩니다 자 그 다음에    dma 컨트롤러는 만약에    하드디스크에다가 메모리의 정보를    백업해라라고 하는 입출력 작업이었다고    가정을 하면은    dma 컨트롤러는    CPU 대신에    cpu를 대행해서    장치 컨트롤러랑 상호작용하면서 입출력    작업을 수행하게 됩니다 그때    필요하다면 dma 컨트롤은    메모리에 직접 접근함으로써    메모리를 직접 읽고 씀으로써    입출력 작업을 수행을 하게 되는    거예요    dma 컨트롤러가 이런 식으로    메모리랑 장치 컨트롤러랑 상호작용    입출력 작업을 한 도중에 cpu는    다른 작업을 할 수가 있게 되겠죠    그렇죠 그리고    메모리랑    장치 컨트롤러 사이에서 주고받는    데이터는    cpu를 거치지 않게 되겠죠 자    마지막으로 입출력 작업이 끝나면    dma 컨트롤러는 인터럽트를 통해서    cpu한테 인터럽트 작업이 끝났음을    이렇게 알리게 됩니다 이게 dma    입출력 과정이다라고 보시면 됩니다    아시겠죠    그렇기 때문에    결과적으로    cpu는    입출력 작업의 시작과 끝만 관여하면    됩니다이 dma를 통해서   <mark style="background: #FF5582A6;"> cpu는 훨씬 더 효율적으로 시간을    쓰면서 입출력 작업을 할 수 있다라는    점 공감이 되</mark>시죠    그렇죠    자 근데 여기서 문제가 있습니다    앞선 예시에서    dna를 하는 과정에서    dma 컨트롤러가 직접적으로 메모리에    접근하는 과정에서    시스템 버스를 이용하는 과정을 한번    볼까요  

![Uploading file...l7tv7]()

자 시스템 버스를 이렇게 이용을 하죠    이게 시스템 메모리는 시스템버스에    연결되어 있고    장치 컨트롤도 지금은 시스템버스에    연결됐다고 가정을 해볼게요 자 그때    당연하게도 메모리를 읽고 쓰기 위해서    dma 컨트롤러는    시스템 버스를 이용을 할 수밖에    없겠죠   <mark style="background: #FF5582A6;"> 그렇죠 자 근데 문제는 뭐냐면    시스템 버스는 공용자원이기 때문에    동시에 사용을 할 수가 없습니다    그러니까 예를 들어서 cpu가 시스템    버스를 이용할 때는    dma 컨트롤러는 쓸 수가 없고요    dma 컨트롤러가 시스템버스를 쓸    때는    cpu가 쓸 수가 없습니다 이런    문제가 있어요</mark> 자 그렇기 때문에    dma 컨트롤러는    cpu가 시스템 버스를 이용하지 않을    때마다 조금 조금씩    야금야금 이제 마치 새벽에 어머니가    끓여주신 김치찌개 고기 빼먹듯이 그냥    조금 조금씩    시스템버스를 빼먹듯이 이용하는 방식이    있고 또 두 번째로는 이제 만약에    시스템 버스를 이용하는 시간이    본의 아니게 겹친다면    cpu가 일시적으로    시스템 버스를 이용하지 않    이런 식으로 이용하는 양상을 사이클    스틸링이라고도 부릅니다
- CPU가 시스템 버스 이용하지 안을 때마다 조그믹 시스템버스 이용
- 사이클 스틸링; CPU가 일시적으로 시스템 버스 이용하지 ㅏㄴㅎ도록 허라 ㄱ구하고 시스템버스 이요 

사이클 스틸링    아시겠죠 자 마지막으로이 입출력    버스에 대한 개념을 설명드리고    강의 마무리 짓도록 하겠습니다    지금까지 예시를 보시면 장치    컨트롤러가 전부 다 시스템버스에    연결이 되어 있죠    그렇죠    근데    장치 컨트롤러가 한두 개가 아니잖아요

### 👯‍♂️ 입출력 버스

```ad-question
title: 장치컨트롤러가 시스템 버스에 직접 연결되어도 괜찮을까? 
```

  사실은 괜찮지는 않습니다 왜냐하면    앞서 이제 보여드렸던 그림을 그림을    보시면 아시겠지만 이렇게    장치 컨트롤러가 시스템버스에    직접적으로 연결되면    dma를 하는 과정에서    dma 컨트롤은 불필요하게 시스템    버스를 두 번씩 이용하게 돼요 예를    들어서    메모리에 있는 정보를    하드디스크에다가 백업한다 이런 과정이    있었을 때 이런 입출력 작업이 있었을    때    읽어들이기 위해서 한번    쓰기 위해서 한번 이렇게 두 번 쓰게    되죠 
  
  
  근데 앞서 말씀드렸듯이 시스템    버스는 공용자원이기 때문에    cpu도 시스템버스를 써야 돼요    그렇기 때문에 너는 누가 시스템버스를    오랫동안 점유하고 있는 것은 결코    좋은게 아닙니다 자 이렇게 불필요하게    시스템버스를 두 번 이용하는 문제를    방지하기 위해서  <mark style="background: #FF5582A6;">  장치 컨트롤러는    직접적으로 시스템버스에 연결되는 것이    아니라이 입출력 버스라고 하는    입출력 전용 버스에 연결이 되게    됩니다 자 이</mark>런 식으로 만약에 장치    컨트롤러들이 입출력 버스에 연결이    된다면    dma 컨트롤러는 굳이 두 번씩이    시스템 버스를 쓸 필요가 없겠죠    만약에 여기서 주고받을 정보가 있다면    이렇게    넣으면 되는 거고 이렇게 읽어들어서    일단 쓰면 되는 거고 불필요하게 두    번씩 시스템 버스를 쓸 필요가    없어지는 거겠죠    
  
  장치 컨트롤러가 시스템버스에    직접적으로 연결됐을 때    과정에서 불필요하게 시스템 버스를    오랫동안 점유하는 이런 문제를    해결하기 위해서 등장하는게 바로    이렇게    입출력 버스의 개념이라고 보시면    됩니다    <mark style="background: #FF5582A6;">입출력 버스    입출력 버스는    종류는 되게 여러가지가 있어요    대</mark>표적으로 이제 PCI 버스    PCI 익스프레스 버스 뭐 이런    버스들이 전부 다 입출력 보스라고    보시면 되는데요 지금이    슬롯 같은 거 있죠    혹시 여러분들 컴퓨터 보시면 이렇게    생긴 슬롯들이 보이실 거예요 이런    이런 슬롯들이 입출력 장치를 연결하는    이런 슬롯들이    결국에는    입출력 버스랑 연결되는 슬롯이라고    보시면 됩니다이 슬롯을 통해서 입출력    버스에 연결이 된다라고 보시면 돼요    <mark style="background: #FF5582A6;">그리고 그 입출력 버스는 결과적으로    시스템 버스에 연결이 돼서    cpu랑 상호작용을 한다든지    메모리랑 상호작용을 한다든지 하게    된다라고 보시면</mark> 되겠습니다 자 이게    바로 입출력 버스다라고 이해하시면    돼요 아시겠죠   
  
   
   
   이제 마지막으로 그 한 가지만 더    말씀을 드리자면이 dma 방식은    최근에는 더욱더 발전을 해서 그    입출력 전용 프로세서를다는 지경까지    이제 발전을 많이 했습니다 그래서  <mark style="background: #FF5582A6;">  입출력 전용 프로세서    입출력 채널이라고도 하는데요 지금    여기 보시면    듀얼코어 cpu를 탑재한 프린터 이런    식으로 이제 광고를 하는 걸 볼 수가    있죠    그러니까    입출력 작업을 해주는    입출력 작업 명령어를 실행하는    것까지도 얘가 해주겠다는 거예요 그게    입출력 전용 프로세서    입출력 채널입니</mark>다 최근에는 이런    식으로    입출력 장치가    램을 답장 경우도 있고    입출력 전용 cpu를 탑재한 경우도    있다라고 보시면 되겠습니다 아시겠죠

## 👯‍♂️ Conclustion

Summarize the main points and conclude your post.

--- 

## 👯‍♂️ Ref & LINKS TO THIS PAGE

-  [책/유튜브 인강-혼자 공부하는 컴퓨터구조+운영체제, 강민철, 한빛미디어](https://www.youtube.com/watch?v=kFWP6sFKyp0&list=PLYH7OjNUOWLUz15j4Q9M6INxK5J3-59GC)