---

title: 11강. 명령어 사이클과 인터럽트

created: 2024-02-27 12:55

last-updated: 2024-03-08 00:22

tags:

- CS

- 책-혼공컴운

- book

---

  

## 👯‍♂️ Intro & tl;dr

  

.. admonition:: TLeod

They contain 3 main parts, the admonition type (the bit before the "::"),

title (the bit after the "::") and body (the text underneath).

  

The admonition type is case insensitive, title is optional and the body

should be able to contain pretty much anything. For example:

  

- Lists

- With multiple levels

- Of indentation

  

And code blocks:

  

print('indented code blocks')

  
  
  

```python

print('hi')

  

```

  

```ad-note

title: 키워드

- 명령어 사이클

- 인출 사이클

- 실행 사이클

- 간접 사이클

- 인터럽트 ✨✨✨ (중요한 개념 )

- 동기 인터럽트 / 비동기 인터럽트

- NMI

- 인터럽트 플래그

- 인터럽트 벡터

- 인터럽트 벡터 테이블

- 인터럽트 서비스 루틴

- 백업 => 메모리의 스특에 저장

```

  

- cpu는 메모리로부터 명령어, 데이터들을 갖고와 실행하고 필요시 값 저장한다.

- 이때 cpu가 메모리에 저장되어 있는 프로그램 실행하는 과정에 일정한 패턴, 일정한 주기가 있다! 👉 즉 cpu는 메모리 안에 있는 프로그램 어떤 정해진 흐름대로 처리하는데 그 정해진 흐름 주기를 명령어 사이클이라고 한다

- 간혹 그 정해진 흐름, 명렁어 사이클 방해한느 신호가 cpu에게 올 수 있는데 이 흐름을 끊는 신호를 인터럽트라고 한다

  

---

  
  

## 👯‍♂️ 명령어 사이클

  

- 즉 cpu는 메모리 안에 있는 프로그램 어떤 정해진 흐름대로 처리하는데 그 정해진 흐름 주기를 명령어 사이클이라고 한다

- 예) 프로그램을 실행한다면? 🤔💭

1. 인출사이클; 메모리에 있는 값을 cpu 레지스터 OR cpu 내부로 갖고온다. 이 작업을 인출이라고 한다, 이렇게 인출하는 주기를 인출사이클이라함

2. 실행사이클; 내부로 가져온 프로그램을 실행한다

👉 일반적으로 cpu는 인출 사이클과 실행 사이클 반복, 이게 명령어 사이클의 일부이다

- 간접사이클; 인출하더라도 곧바로 실행되는게 아니라 추가적으로 메모리에 접근해야하는 경우도있다. (간접 주소 지정 방식, 몇번 더 메모리에 접근해야하는 경우가) 이렇게 메모리접근 더 필요하면 간접사이클 돌입하게 되고 간접사이클 끝나면 실행사이클로 돌아간다.

  

![](https://i.imgur.com/p1jq7le.png)

  

  

## 👯‍♂️ 인터럽트

  

- 인터럽트; 정해진 흐름 대로(명령어 사이클대로) cpu가 프로그램 처리하고 있는데 정해진 흐름을 끊어버리는 신호. CPU가 얼른 처리해야하는 작업 생겼을 때 인터럽트 발생

- 동기인터럽트(aka. 예외 Exception): CPU가 예기치 못한 상황 접했을때 발생. 0으로 나누거나 메모리 주소에 접근했는데 원하는 데이터가 없는등 etc

- 폴트

- 트랩

- 중단(abort)

- 소프트웨어 인터럽트

- 비동기인터럽트(aka. 하드웨어 인터럽트): 주로 입출력 장치에의해 발생. 알림과 같은 역할. 전자렌지나 세탁기가 작업 완료 되면 울리는 알림. CPU가 프린터한테 "프린트하고 있어! 그리고 내가 다른 일 할 동안 프린트가 다 완료되면 다시 불러줘"라고 하면 이 하드웨어가 CPU한테 보내는 알림

  

### 👯‍♂️ 비동기 인터럽트

  

- 왜쓰는거지?; CPU가 입출력 작업 도중에도 효율적으로 명령어 처리하기위해. 입출력 장치 입출력 작업은 보통 CPU에 비해 느림. 만약에 HW 인터럽트가 없었다면 CPU가 계속해서 입출력작업 완료 여부 확인 하기 위해 주기적으로 확인을 해줘야한다. 근데 HW 인터럽트가 있어서 다른일 할 동안 완료되면 알림으로 작업 종료 여부를 알 수 있어 그 동안 확인이 나리 다른 일을 할 수있게 되는것! 비로소 그 입출력 작업끝나면 하던일 중단하고 그 알림 확인하면 된느것임

### 👯‍♂️ 인터럽트 처리순서와 서비스 루틴

  
  
  

<mark style="background: #FF5582A6;">인터럽트 처리순서</mark>

👉 입출력 장치는 cpu한테 인터럽트 요청 신호를 보냅니다

👉그리고 cpu는 실행 사이클이 끝나고 명령어를 인출하기 전에 항상 인터럽트가 있었나 인터럽트를 받아들일 수 있었나 뭐 이런 식으로

인터럽트 여부를 확인합니다

👉그리고 cpu가 인터럽트 요청을 확인하면 어 이런 알람이 있었네 어 이런 알림이 있었네 이런 식으로 인터럽트 요청을 확인을 하면은

👉플래그 레지스터에 있는 인터럽트 플래그를 통해서 현재 인터럽트를 받아들일 수 있는지이 인터럽트를 지금 처리할 수 있는지 여부를 확인을 합니다 만약에 이런 것들이 처리할 수 있다면 cpu는 지금까지 했던 작업을 잠시 백업을 하고요 (자기가 실행 중인 프로그램을 쭉 실행을 하다가 만약에 인터럽트가 땅 발생을 하면은 해당 명령어까지는 실행을 끝내고 그 인터럽트로 도달아서 되돌아가서 그 인터럽트를 실행한 다음에 다시 되돌아와서 수행을 제기하게 됩니다)

👉 인터럽트 벡터를 참조해서 인터럽트 서비스 루틴이라고 하는 프로그램을 실행합니다 이거 다 무슨

👉 인터럽트 서비스 루팅 실행이 끝나면 여기서 백업해둔 잠시 백업해둔 그 작업을 복구해서 다시 하던 일을

  
  

- 인터럽트 요청신호; HW 인터럽트를 보내는 주체들(키보드, 마우스같은)이 CPU한테 지금 끼어들어도 되나요?라고 요청을 보내는 신호. 인터럽트는 CPU 정상적 실행 흐름 끊는 것이기 때문에 이런식으로 요청신호를 보내게 된다

- CPU는 이런식으로 인터럽트 요청신호를 받으면 실행사이클 끝나고 명령어 인출 전 플래그 레지스터 속 인터럽트 플래그를 확인한다

- 인터럽트 플래그; 현재 인터럽트를 받아들일 수 있다 없다를 0,1과 1로 표기한것. 받아 들일 수 있는 상황이면 인터럽트 처리하고 그렇지 않으면 인터럽트 요청신호와도 해당 인터럽트 처리 X 👉👉👉👉 근데 인터럽트 플래그 여부로 모든 인터럽트 처리를 막을 수 있는건 아니다!! 꼭 처리해야하는 긴급 인터럽트는 인터럽트 플래그로도 막을 수 없다 🥵🥵🥵🥵🥵 이러한 인터럽트를 Non-maskable interrupt (NMI interrupt)라고 한다 . 하드웨어 고장이나 정전같은 경우

- 인터럽트 서비스 루틴; 메모리 안에서 실행되는 프로그램의 일종인데 이는 인러터럽트가 발생 했을 때 해당 인터럽트를 어떻게 처리하면 되는지 적혀있는 프로그램 HW(⌨️🖱️🔊)들이 인터럽트 요청을 보내면 이렇게 행동하세요~ 라고 적혀있는 프로그램. 이것또한 프로그램이라서 메모리에 저장되어있고 인터럽트 보내는 주체 따라 각기 시작 주소를 갖고 있다. 프린터(or 키보드)기 인터럽스 서비스 루틴은 프린터(or 키보드)가 인터럽트 신호 보내면 해당 인터럽트를 어떻게 처리한다라고 적혀있다! 인터럽트를 보낼 수 있는 주체에 따라 각기 다른 인터럽트 서비스 루틴을 갖고 있다

-

![](https://i.imgur.com/xVssNp7.png)

  

cpu가 인터럽트를 받아들이기로 했다면 여기서 처리하는 명령까지는 처리를 한 다음에 그 인터럽트에 해당하는 인터럽트 서비스 루틴으로 점프를 합니다 그리고 그 인터럽트 서비스 루틴을 쭉 실행을 하고 아까 전에 점프했던 곳으로 되돌아간 다음에 다시 수행을 재개합니다

  
  

- 인터럽트 벡터; 다시 말해서 인터럽트마다 고유한 인터럽트 서비스 루틴의 시작 주소를 가지고 있습니다 예를 들어서 만약에 얘가 키보드의 인터럽트 서비스 루틴이었다면 키보드 인터럽트 서비스 루틴의 시작 주소는 여기겠죠 그럼 cpu는 이렇게 인터럽트를 보낼 수 있는 주체에 따라서 인터럽트 서비스 루틴의 시작 주소가 달라질 수 있는데 cpu가 해당 인터럽트 서비스 루틴의 시작 주소는 무엇인지 그 인터럽트를 구분할 수 있는 정보가 필요하겠죠 각각의 인터럽트를 구분하기 위한 정보를 인터럽트 벡터 라고함.

  

![](https://i.imgur.com/xmLZ5wA.png)

  

- 인터럽트 벡터 테이블 인터럽트 벡터를 통해서 쭉 모아놓은 표의 형태로 모아놓은 인터럽트 벡터들을 표처럼 모아놓은 인터럽트 벡터 테이블 이라고 하는 것도 여기 있습니다 메모리에 아시겠죠

- 인터럽트 벡터 = 각 각의 인터럽트 구분하기 위한 정보

- 인터럽트 벡터 왜 필요? = CPU가 해당 인터럽트 서비스 루틴 시작 주소 알기 위해 필요. 보통 인터럽트 보내는 주체가 해당 인터럽트 요청신호와 인터럽트 벡터도 데이터 버스를 통해 보내게 된다

  

- CPU가 인터럽트를 처리한다 = 인터럽트 서비스 루틴을 실행하고 원래 수행하던 작업으로 표현한다.

- 백업?; CPU가 인터럽트 요청신호 받아 처리하려면 인터럽트 서비스 루틴으로 점프해 인터럽트 서비스 루틴을 실행하고 원래 작업으로 돌아온다. 근데 기존에 작업 처리하기 위해 프로그램 카운터나 레지스터에 저장된 값들은 어떻

  
  
  

![](https://i.imgur.com/jSvjdn1.png)

  
  

```

```

  

인터럽트 서비스 루틴을 실행하게 되면 만약에 10번지에 있는 인터럽트 서비스 루트는 실행하면 이것들을 프로그램 카운터라고 한다면 1,500을 10으로 바꿔야겠죠

그렇죠 근데이 1,500이라고 하는이 값 있죠 다음 실행할 명령어는 1500번지야라고 하는 이런 레지스터 값들을 그냥 버려 버리면 될까요 그럼 안 됩니다 왜냐면 언제든 다시 되돌아와서 수행을 재개해야 되기 때문에 현재 레지스터에는 어떤 값들이 담겨있는지 현재 이제 cpu는 어떤 상태인지가 다 기억이 되어 있어야 돼요 그렇기 때문에 인터럽트로 점프하는 것은 좋은데 그 전에 그 전에 지금까지 했던 작업을 어디다가 백업을 한 다음에 그 다음에 인터럽트 서비스로 등을 실행하면서 이런저런 레지스터 값들을 사용을 해야 됩니다 인터럽트 서비스 루틴도 프로그램이니까 당연히 이런저런 레지스터를 쓸 거 아니에요 그쵸 근데 그 전까지 있었던 레지스터들은 어딘가에 백업을 해둬야 된다고요

그렇죠 자 이러기 위해서 <mark style="background: #FF5582A6;">그걸 위해서

  

백업을 하기 위해서 지금까지의 작업

  

내용 이를테면 뭐 레지스터 안에 담겨

  

있는 이런 값들은 전부 다

  

스택에 백업을 해두게 됩니다 그

</mark>

다음에 인터럽트 서비스 루틴을 위해서 이제 레지스터를 쓸 수가 있는 거죠 이런 식으로 그럼 이제 인터럽트 서비스 루틴을 실행하기 위한 어떤 정보들이 레지스터 안에 담기게 되고 가령 프로그램 카운터에는 10 11 12 이런 식으로 담길 수가 있겠죠 그쵸 자 만약에 인터럽 서비스 루틴에 실행이 끝났다라고 하면은 다시 이거를 쭉 복구를 해서 다시 프로그램 카운터 값은 1500이야 메모리 주소 레지스터에는 이런 값이 있었고 뭐 범용 레지스터에는 이런 값이 있었어 뭐 이런 식으로 다시 스택에서 백업을 해오게 됩니다 그러면 다음 다음 실행할 명령어가 어딘지 알 수 있겠죠 그쵸 곧바로 다음으로 실행할 명령어부터 쭉 수행을 제기할 수가 있겠죠 그죠 인터럽트가 발생하면은 지금 상태를 백업하고 해당 인터럽트 서비스로 진에 해당하는 것들을 쭉 cpu로 갖고 와서 실행을 하게 된다라고 보시면 됩니다 자 그럼

  
  

## 👯‍♂️ Conclustion

  
  

---

  

## 👯‍♂️ Ref & LINKS TO THIS PAGE

  

- [책/유튜브 인강-혼자 공부하는 컴퓨터구조+운영체제, 강민철, 한빛미디어](https://www.youtube.com/watch?v=kFWP6sFKyp0&list=PLYH7OjNUOWLUz15j4Q9M6INxK5J3-59GC)